'use strict';

const applyTimestampsToChildren = require('../update/applyTimestampsToChildren');
const applyTimestampsToUpdate = require('../update/applyTimestampsToUpdate');
const get = require('../get');
const handleTimestampOption = require('../schema/handleTimestampOption');
<<<<<<< HEAD
const symbols = require('../../schema/symbols');

module.exports = function setupTimestamps(schema, timestamps) {
  const childHasTimestamp = schema.childSchemas.find(withTimestamp);

=======
const setDocumentTimestamps = require('./setDocumentTimestamps');
const symbols = require('../../schema/symbols');

const replaceOps = new Set([
  'replaceOne',
  'findOneAndReplace'
]);

module.exports = function setupTimestamps(schema, timestamps) {
  const childHasTimestamp = schema.childSchemas.find(withTimestamp);
>>>>>>> origin/wsj
  function withTimestamp(s) {
    const ts = s.schema.options.timestamps;
    return !!ts;
  }
<<<<<<< HEAD

  if (!timestamps && !childHasTimestamp) {
    return;
  }

=======
  if (!timestamps && !childHasTimestamp) {
    return;
  }
>>>>>>> origin/wsj
  const createdAt = handleTimestampOption(timestamps, 'createdAt');
  const updatedAt = handleTimestampOption(timestamps, 'updatedAt');
  const currentTime = timestamps != null && timestamps.hasOwnProperty('currentTime') ?
    timestamps.currentTime :
    null;
  const schemaAdditions = {};

  schema.$timestamps = { createdAt: createdAt, updatedAt: updatedAt };

<<<<<<< HEAD
=======
  if (createdAt && !schema.paths[createdAt]) {
    const baseImmutableCreatedAt = schema.base != null ? schema.base.get('timestamps.createdAt.immutable') : null;
    const immutable = baseImmutableCreatedAt != null ? baseImmutableCreatedAt : true;
    schemaAdditions[createdAt] = { [schema.options.typeKey || 'type']: Date, immutable };
  }

>>>>>>> origin/wsj
  if (updatedAt && !schema.paths[updatedAt]) {
    schemaAdditions[updatedAt] = Date;
  }

<<<<<<< HEAD
  if (createdAt && !schema.paths[createdAt]) {
    schemaAdditions[createdAt] = Date;
  }

  schema.add(schemaAdditions);

  schema.pre('save', function(next) {
=======
  schema.add(schemaAdditions);

  schema.pre('save', function timestampsPreSave(next) {
>>>>>>> origin/wsj
    const timestampOption = get(this, '$__.saveOptions.timestamps');
    if (timestampOption === false) {
      return next();
    }

<<<<<<< HEAD
    const skipUpdatedAt = timestampOption != null && timestampOption.updatedAt === false;
    const skipCreatedAt = timestampOption != null && timestampOption.createdAt === false;

    const defaultTimestamp = currentTime != null ?
      currentTime() :
      (this.ownerDocument ? this.ownerDocument() : this).constructor.base.now();
    const auto_id = this._id && this._id.auto;

    if (!skipCreatedAt && createdAt && !this.get(createdAt) && this.$__isSelected(createdAt)) {
      this.$set(createdAt, auto_id ? this._id.getTimestamp() : defaultTimestamp);
    }

    if (!skipUpdatedAt && updatedAt && (this.isNew || this.isModified())) {
      let ts = defaultTimestamp;
      if (this.isNew) {
        if (createdAt != null) {
          ts = this.$__getValue(createdAt);
        } else if (auto_id) {
          ts = this._id.getTimestamp();
        }
      }
      this.$set(updatedAt, ts);
    }
=======
    setDocumentTimestamps(this, timestampOption, currentTime, createdAt, updatedAt);
>>>>>>> origin/wsj

    next();
  });

  schema.methods.initializeTimestamps = function() {
    const ts = currentTime != null ?
<<<<<<< HEAD
      currentTime() :
      this.constructor.base.now();
=======
      currentTime() : this.constructor.base.now();


>>>>>>> origin/wsj
    if (createdAt && !this.get(createdAt)) {
      this.$set(createdAt, ts);
    }
    if (updatedAt && !this.get(updatedAt)) {
      this.$set(updatedAt, ts);
    }
<<<<<<< HEAD
=======
    if (this.$isSubdocument) {
      return this;
    }

    const subdocs = this.$getAllSubdocs();
    for (const subdoc of subdocs) {
      if (subdoc.initializeTimestamps) {
        subdoc.initializeTimestamps();
      }
    }

>>>>>>> origin/wsj
    return this;
  };

  _setTimestampsOnUpdate[symbols.builtInMiddleware] = true;

  const opts = { query: true, model: false };
  schema.pre('findOneAndReplace', opts, _setTimestampsOnUpdate);
  schema.pre('findOneAndUpdate', opts, _setTimestampsOnUpdate);
  schema.pre('replaceOne', opts, _setTimestampsOnUpdate);
  schema.pre('update', opts, _setTimestampsOnUpdate);
  schema.pre('updateOne', opts, _setTimestampsOnUpdate);
  schema.pre('updateMany', opts, _setTimestampsOnUpdate);

  function _setTimestampsOnUpdate(next) {
    const now = currentTime != null ?
      currentTime() :
      this.model.base.now();
<<<<<<< HEAD

    // Replacing with null update should still trigger timestamps
    if (this.op === 'findOneAndReplace' && this.getUpdate() == null) {
      this.setUpdate({});
    }

    applyTimestampsToUpdate(now, createdAt, updatedAt, this.getUpdate(),
      this.options, this.schema);
    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
    next();
  }
};
=======
    // Replacing with null update should still trigger timestamps
    if (replaceOps.has(this.op) && this.getUpdate() == null) {
      this.setUpdate({});
    }
    applyTimestampsToUpdate(
      now,
      createdAt,
      updatedAt,
      this.getUpdate(),
      this._mongooseOptions,
      replaceOps.has(this.op)
    );
    applyTimestampsToChildren(now, this.getUpdate(), this.model.schema);
    next();
  }
};
>>>>>>> origin/wsj
