'use strict';

const Document = require('../document');
const immediate = require('../helpers/immediate');
const internalToObjectOptions = require('../options').internalToObjectOptions;
<<<<<<< HEAD
const promiseOrCallback = require('../helpers/promiseOrCallback');

const documentArrayParent = require('../helpers/symbols').documentArrayParent;
=======
const util = require('util');
const utils = require('../utils');
>>>>>>> origin/wsj

module.exports = Subdocument;

/**
 * Subdocument constructor.
 *
 * @inherits Document
 * @api private
 */

function Subdocument(value, fields, parent, skipId, options) {
<<<<<<< HEAD
  this.$isSingleNested = true;
  if (options != null && options.path != null) {
    this.$basePath = options.path;
  }
  const hasPriorDoc = options != null && options.priorDoc;
  let initedPaths = null;
  if (hasPriorDoc) {
    this._doc = Object.assign({}, options.priorDoc._doc);
    delete this._doc[this.$__schema.options.discriminatorKey];
    initedPaths = Object.keys(options.priorDoc._doc || {}).
      filter(key => key !== this.$__schema.options.discriminatorKey);
  }
  if (parent != null) {
    // If setting a nested path, should copy isNew from parent re: gh-7048
    options = Object.assign({}, options, {
      isNew: parent.isNew,
      defaults: parent.$__.$options.defaults
    });
  }
  Document.call(this, value, fields, skipId, options);

  if (hasPriorDoc) {
    for (const key of initedPaths) {
      if (!this.$__.activePaths.states.modify[key] &&
          !this.$__.activePaths.states.default[key] &&
          !this.$__.$setCalled.has(key)) {
        const schematype = this.$__schema.path(key);
        const def = schematype == null ? void 0 : schematype.getDefault(this);
        if (def === void 0) {
          delete this._doc[key];
        } else {
          this._doc[key] = def;
          this.$__.activePaths.default(key);
        }
      }
    }

    delete options.priorDoc;
    delete this.$__.$options.priorDoc;
  }
=======
  if (typeof skipId === 'object' && skipId != null && options == null) {
    options = skipId;
    skipId = undefined;
  }
  if (parent != null) {
    // If setting a nested path, should copy isNew from parent re: gh-7048
    const parentOptions = { isNew: parent.isNew };
    if ('defaults' in parent.$__) {
      parentOptions.defaults = parent.$__.defaults;
    }
    options = Object.assign(parentOptions, options);
  }
  if (options != null && options.path != null) {
    this.$basePath = options.path;
  }
  Document.call(this, value, fields, skipId, options);

  delete this.$__.priorDoc;
>>>>>>> origin/wsj
}

Subdocument.prototype = Object.create(Document.prototype);

<<<<<<< HEAD
=======
Object.defineProperty(Subdocument.prototype, '$isSubdocument', {
  configurable: false,
  writable: false,
  value: true
});

Object.defineProperty(Subdocument.prototype, '$isSingleNested', {
  configurable: false,
  writable: false,
  value: true
});

/*!
 * ignore
 */

>>>>>>> origin/wsj
Subdocument.prototype.toBSON = function() {
  return this.toObject(internalToObjectOptions);
};

/**
 * Used as a stub for middleware
 *
<<<<<<< HEAD
 * ####NOTE:
=======
 * #### Note:
>>>>>>> origin/wsj
 *
 * _This is a no-op. Does not actually save the doc to the db._
 *
 * @param {Function} [fn]
 * @return {Promise} resolved Promise
 * @api private
 */

<<<<<<< HEAD
Subdocument.prototype.save = function(options, fn) {
  if (typeof options === 'function') {
    fn = options;
    options = {};
  }
  options = options || {};

  if (!options.suppressWarning) {
    console.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
=======
Subdocument.prototype.save = async function save(options) {
  options = options || {};

  if (!options.suppressWarning) {
    utils.warn('mongoose: calling `save()` on a subdoc does **not** save ' +
>>>>>>> origin/wsj
      'the document to MongoDB, it only runs save middleware. ' +
      'Use `subdoc.save({ suppressWarning: true })` to hide this warning ' +
      'if you\'re sure this behavior is right for your app.');
  }

<<<<<<< HEAD
  return promiseOrCallback(fn, cb => {
    this.$__save(cb);
=======
  return new Promise((resolve, reject) => {
    this.$__save((err) => {
      if (err != null) {
        return reject(err);
      }
      resolve(this);
    });
>>>>>>> origin/wsj
  });
};

/**
<<<<<<< HEAD
 * Used as a stub for middleware
 *
 * ####NOTE:
=======
 * Given a path relative to this document, return the path relative
 * to the top-level document.
 * @param {String} path
 * @method $__fullPath
 * @memberOf Subdocument
 * @instance
 * @returns {String}
 * @api private
 */

Subdocument.prototype.$__fullPath = function(path) {
  if (!this.$__.fullPath) {
    this.ownerDocument();
  }

  return path ?
    this.$__.fullPath + '.' + path :
    this.$__.fullPath;
};

/**
 * Given a path relative to this document, return the path relative
 * to the parent document.
 * @param {String} p
 * @returns {String}
 * @method $__pathRelativeToParent
 * @memberOf Subdocument
 * @instance
 * @api private
 */

Subdocument.prototype.$__pathRelativeToParent = function(p) {
  if (p == null) {
    return this.$basePath;
  }
  return [this.$basePath, p].join('.');
};

/**
 * Used as a stub for middleware
 *
 * #### Note:
>>>>>>> origin/wsj
 *
 * _This is a no-op. Does not actually save the doc to the db._
 *
 * @param {Function} [fn]
 * @method $__save
 * @api private
 */

Subdocument.prototype.$__save = function(fn) {
  return immediate(() => fn(null, this));
};

<<<<<<< HEAD
Subdocument.prototype.$isValid = function(path) {
  if (this.$__parent && this.$basePath) {
    return this.$__parent.$isValid([this.$basePath, path].join('.'));
=======
/*!
 * ignore
 */

Subdocument.prototype.$isValid = function(path) {
  const parent = this.$parent();
  const fullPath = this.$__pathRelativeToParent(path);
  if (parent != null && fullPath != null) {
    return parent.$isValid(fullPath);
>>>>>>> origin/wsj
  }
  return Document.prototype.$isValid.call(this, path);
};

<<<<<<< HEAD
Subdocument.prototype.markModified = function(path) {
  Document.prototype.markModified.call(this, path);

  if (this.$__parent && this.$basePath) {
    if (this.$__parent.isDirectModified(this.$basePath)) {
      return;
    }
    this.$__parent.markModified([this.$basePath, path].join('.'), this);
  }
};

Subdocument.prototype.isModified = function(paths, modifiedPaths) {
  if (this.$__parent && this.$basePath) {
    if (Array.isArray(paths) || typeof paths === 'string') {
      paths = (Array.isArray(paths) ? paths : paths.split(' '));
      paths = paths.map(p => [this.$basePath, p].join('.'));

      return this.$__parent.isModified(paths, modifiedPaths);
    }

    return this.$__parent.isModified(this.$basePath);
  }

  return Document.prototype.isModified.call(this, paths, modifiedPaths);
=======
/*!
 * ignore
 */

Subdocument.prototype.markModified = function(path) {
  Document.prototype.markModified.call(this, path);
  const parent = this.$parent();
  const fullPath = this.$__pathRelativeToParent(path);

  if (parent == null || fullPath == null) {
    return;
  }

  const myPath = this.$__pathRelativeToParent().replace(/\.$/, '');
  if (parent.isDirectModified(myPath) || this.isNew) {
    return;
  }
  this.$__parent.markModified(fullPath, this);
};

/*!
 * ignore
 */

Subdocument.prototype.isModified = function(paths, options, modifiedPaths) {
  const parent = this.$parent();
  if (parent != null) {
    if (Array.isArray(paths) || typeof paths === 'string') {
      paths = (Array.isArray(paths) ? paths : paths.split(' '));
      paths = paths.map(p => this.$__pathRelativeToParent(p)).filter(p => p != null);
    } else if (!paths) {
      paths = this.$__pathRelativeToParent();
    }

    return parent.$isModified(paths, options, modifiedPaths);
  }

  return Document.prototype.isModified.call(this, paths, options, modifiedPaths);
>>>>>>> origin/wsj
};

/**
 * Marks a path as valid, removing existing validation errors.
 *
 * @param {String} path the field to mark as valid
 * @api private
 * @method $markValid
<<<<<<< HEAD
 * @receiver Subdocument
=======
 * @memberOf Subdocument
>>>>>>> origin/wsj
 */

Subdocument.prototype.$markValid = function(path) {
  Document.prototype.$markValid.call(this, path);
<<<<<<< HEAD
  if (this.$__parent && this.$basePath) {
    this.$__parent.$markValid([this.$basePath, path].join('.'));
=======
  const parent = this.$parent();
  const fullPath = this.$__pathRelativeToParent(path);
  if (parent != null && fullPath != null) {
    parent.$markValid(fullPath);
>>>>>>> origin/wsj
  }
};

/*!
 * ignore
 */

Subdocument.prototype.invalidate = function(path, err, val) {
<<<<<<< HEAD
  // Hack: array subdocuments' validationError is equal to the owner doc's,
  // so validating an array subdoc gives the top-level doc back. Temporary
  // workaround for #5208 so we don't have circular errors.
  if (err !== this.ownerDocument().$__.validationError) {
    Document.prototype.invalidate.call(this, path, err, val);
  }

  if (this.$__parent && this.$basePath) {
    this.$__parent.invalidate([this.$basePath, path].join('.'), err, val);
  } else if (err.kind === 'cast' || err.name === 'CastError') {
=======
  Document.prototype.invalidate.call(this, path, err, val);

  const parent = this.$parent();
  const fullPath = this.$__pathRelativeToParent(path);
  if (parent != null && fullPath != null) {
    parent.invalidate(fullPath, err, val);
  } else if (err.kind === 'cast' || err.name === 'CastError' || fullPath == null) {
>>>>>>> origin/wsj
    throw err;
  }

  return this.ownerDocument().$__.validationError;
};

/*!
 * ignore
 */

Subdocument.prototype.$ignore = function(path) {
  Document.prototype.$ignore.call(this, path);
<<<<<<< HEAD
  if (this.$__parent && this.$basePath) {
    this.$__parent.$ignore([this.$basePath, path].join('.'));
=======
  const parent = this.$parent();
  const fullPath = this.$__pathRelativeToParent(path);
  if (parent != null && fullPath != null) {
    parent.$ignore(fullPath);
>>>>>>> origin/wsj
  }
};

/**
 * Returns the top level document of this sub-document.
 *
 * @return {Document}
 */

Subdocument.prototype.ownerDocument = function() {
  if (this.$__.ownerDocument) {
    return this.$__.ownerDocument;
  }

<<<<<<< HEAD
  let parent = this.$__parent;
  if (!parent) {
    return this;
  }

  while (parent.$__parent || parent[documentArrayParent]) {
    parent = parent.$__parent || parent[documentArrayParent];
  }
=======
  let parent = this; // eslint-disable-line consistent-this
  const paths = [];
  const seenDocs = new Set([parent]);

  while (true) {
    if (typeof parent.$__pathRelativeToParent !== 'function') {
      break;
    }
    paths.unshift(parent.$__pathRelativeToParent(void 0, true));
    const _parent = parent.$parent();
    if (_parent == null) {
      break;
    }
    parent = _parent;
    if (seenDocs.has(parent)) {
      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');
    }

    seenDocs.add(parent);
  }

  this.$__.fullPath = paths.join('.');
>>>>>>> origin/wsj

  this.$__.ownerDocument = parent;
  return this.$__.ownerDocument;
};

<<<<<<< HEAD
=======
/*!
 * ignore
 */

Subdocument.prototype.$__fullPathWithIndexes = function() {
  let parent = this; // eslint-disable-line consistent-this
  const paths = [];
  const seenDocs = new Set([parent]);

  while (true) {
    if (typeof parent.$__pathRelativeToParent !== 'function') {
      break;
    }
    paths.unshift(parent.$__pathRelativeToParent(void 0, false));
    const _parent = parent.$parent();
    if (_parent == null) {
      break;
    }
    parent = _parent;
    if (seenDocs.has(parent)) {
      throw new Error('Infinite subdocument loop: subdoc with _id ' + parent._id + ' is a parent of itself');
    }

    seenDocs.add(parent);
  }

  return paths.join('.');
};

>>>>>>> origin/wsj
/**
 * Returns this sub-documents parent document.
 *
 * @api public
 */

Subdocument.prototype.parent = function() {
  return this.$__parent;
};

/**
 * Returns this sub-documents parent document.
 *
 * @api public
<<<<<<< HEAD
=======
 * @method $parent
>>>>>>> origin/wsj
 */

Subdocument.prototype.$parent = Subdocument.prototype.parent;

<<<<<<< HEAD
/*!
 * no-op for hooks
 */

Subdocument.prototype.$__remove = function(cb) {
=======
/**
 * no-op for hooks
 * @param {Function} cb
 * @method $__deleteOne
 * @memberOf Subdocument
 * @instance
 * @api private
 */

Subdocument.prototype.$__deleteOne = function(cb) {
  if (cb == null) {
    return;
  }
>>>>>>> origin/wsj
  return cb(null, this);
};

/**
<<<<<<< HEAD
=======
 * ignore
 * @method $__removeFromParent
 * @memberOf Subdocument
 * @instance
 * @api private
 */

Subdocument.prototype.$__removeFromParent = function() {
  this.$__parent.set(this.$basePath, null);
};

/**
>>>>>>> origin/wsj
 * Null-out this subdoc
 *
 * @param {Object} [options]
 * @param {Function} [callback] optional callback for compatibility with Document.prototype.remove
 */

<<<<<<< HEAD
Subdocument.prototype.remove = function(options, callback) {
=======
Subdocument.prototype.deleteOne = function(options, callback) {
>>>>>>> origin/wsj
  if (typeof options === 'function') {
    callback = options;
    options = null;
  }
  registerRemoveListener(this);

  // If removing entire doc, no need to remove subdoc
  if (!options || !options.noop) {
<<<<<<< HEAD
    this.$__parent.set(this.$basePath, null);
  }

  if (typeof callback === 'function') {
    callback(null);
  }
=======
    this.$__removeFromParent();

    const owner = this.ownerDocument();
    owner.$__.removedSubdocs = owner.$__.removedSubdocs || [];
    owner.$__.removedSubdocs.push(this);
  }

  return this.$__deleteOne(callback);
>>>>>>> origin/wsj
};

/*!
 * ignore
 */

Subdocument.prototype.populate = function() {
  throw new Error('Mongoose does not support calling populate() on nested ' +
    'docs. Instead of `doc.nested.populate("path")`, use ' +
    '`doc.populate("nested.path")`');
};

<<<<<<< HEAD
/*!
=======
/**
 * Helper for console.log
 *
 * @api public
 */

Subdocument.prototype.inspect = function() {
  return this.toObject();
};

if (util.inspect.custom) {
  // Avoid Node deprecation warning DEP0079
  Subdocument.prototype[util.inspect.custom] = Subdocument.prototype.inspect;
}

/**
>>>>>>> origin/wsj
 * Registers remove event listeners for triggering
 * on subdocuments.
 *
 * @param {Subdocument} sub
 * @api private
 */

function registerRemoveListener(sub) {
<<<<<<< HEAD
  let owner = sub.ownerDocument();

  function emitRemove() {
    owner.removeListener('save', emitRemove);
    owner.removeListener('remove', emitRemove);
    sub.emit('remove', sub);
    sub.constructor.emit('remove', sub);
    owner = sub = null;
  }

  owner.on('save', emitRemove);
  owner.on('remove', emitRemove);
=======
  const owner = sub.ownerDocument();

  function emitRemove() {
    owner.$removeListener('save', emitRemove);
    owner.$removeListener('deleteOne', emitRemove);
    sub.emit('deleteOne', sub);
    sub.constructor.emit('deleteOne', sub);
  }

  owner.$on('save', emitRemove);
  owner.$on('deleteOne', emitRemove);
>>>>>>> origin/wsj
}
