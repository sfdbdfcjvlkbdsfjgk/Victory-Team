'use strict';

/*!
 * Module dependencies.
 */

<<<<<<< HEAD
const EventEmitter = require('events').EventEmitter;
const InternalCache = require('./internal');
const MongooseError = require('./error/index');
const MixedSchema = require('./schema/mixed');
=======
const DivergentArrayError = require('./error/divergentArray');
const EventEmitter = require('events').EventEmitter;
const InternalCache = require('./internal');
const MongooseBuffer = require('./types/buffer');
const MongooseError = require('./error/index');
const MixedSchema = require('./schema/mixed');
const ModifiedPathsSnapshot = require('./modifiedPathsSnapshot');
>>>>>>> origin/wsj
const ObjectExpectedError = require('./error/objectExpected');
const ObjectParameterError = require('./error/objectParameter');
const ParallelValidateError = require('./error/parallelValidate');
const Schema = require('./schema');
const StrictModeError = require('./error/strict');
const ValidationError = require('./error/validation');
const ValidatorError = require('./error/validator');
<<<<<<< HEAD
const VirtualType = require('./virtualtype');
const promiseOrCallback = require('./helpers/promiseOrCallback');
const cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');
const compile = require('./helpers/document/compile').compile;
const defineKey = require('./helpers/document/compile').defineKey;
const flatten = require('./helpers/common').flatten;
const get = require('./helpers/get');
const getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');
const handleSpreadDoc = require('./helpers/document/handleSpreadDoc');
const idGetter = require('./plugins/idGetter');
const immediate = require('./helpers/immediate');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const isExclusive = require('./helpers/projection/isExclusive');
const inspect = require('util').inspect;
const internalToObjectOptions = require('./options').internalToObjectOptions;
const mpath = require('mpath');
const queryhelpers = require('./queryhelpers');
const utils = require('./utils');
const isPromise = require('./helpers/isPromise');

const clone = utils.clone;
const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;

const arrayAtomicsBackupSymbol = Symbol('mongoose.Array#atomicsBackup');
=======
const $__hasIncludedChildren = require('./helpers/projection/hasIncludedChildren');
const applyDefaults = require('./helpers/document/applyDefaults');
const cleanModifiedSubpaths = require('./helpers/document/cleanModifiedSubpaths');
const clone = require('./helpers/clone');
const compile = require('./helpers/document/compile').compile;
const defineKey = require('./helpers/document/compile').defineKey;
const firstKey = require('./helpers/firstKey');
const flatten = require('./helpers/common').flatten;
const getEmbeddedDiscriminatorPath = require('./helpers/document/getEmbeddedDiscriminatorPath');
const getKeysInSchemaOrder = require('./helpers/schema/getKeysInSchemaOrder');
const getSubdocumentStrictValue = require('./helpers/schema/getSubdocumentStrictValue');
const handleSpreadDoc = require('./helpers/document/handleSpreadDoc');
const immediate = require('./helpers/immediate');
const isBsonType = require('./helpers/isBsonType');
const isDefiningProjection = require('./helpers/projection/isDefiningProjection');
const isExclusive = require('./helpers/projection/isExclusive');
const isPathExcluded = require('./helpers/projection/isPathExcluded');
const inspect = require('util').inspect;
const internalToObjectOptions = require('./options').internalToObjectOptions;
const markArraySubdocsPopulated = require('./helpers/populate/markArraySubdocsPopulated');
const minimize = require('./helpers/minimize');
const mpath = require('mpath');
const parentPaths = require('./helpers/path/parentPaths');
const queryhelpers = require('./queryHelpers');
const utils = require('./utils');
const isPromise = require('./helpers/isPromise');

const deepEqual = utils.deepEqual;
const isMongooseObject = utils.isMongooseObject;

const arrayAtomicsBackupSymbol = require('./helpers/symbols').arrayAtomicsBackupSymbol;
>>>>>>> origin/wsj
const arrayAtomicsSymbol = require('./helpers/symbols').arrayAtomicsSymbol;
const documentArrayParent = require('./helpers/symbols').documentArrayParent;
const documentIsModified = require('./helpers/symbols').documentIsModified;
const documentModifiedPaths = require('./helpers/symbols').documentModifiedPaths;
const documentSchemaSymbol = require('./helpers/symbols').documentSchemaSymbol;
const getSymbol = require('./helpers/symbols').getSymbol;
<<<<<<< HEAD
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;
const scopeSymbol = require('./helpers/symbols').scopeSymbol;
const schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;
=======
const modelSymbol = require('./helpers/symbols').modelSymbol;
const populateModelSymbol = require('./helpers/symbols').populateModelSymbol;
const scopeSymbol = require('./helpers/symbols').scopeSymbol;
const schemaMixedSymbol = require('./schema/symbols').schemaMixedSymbol;
const getDeepestSubdocumentForPath = require('./helpers/document/getDeepestSubdocumentForPath');
const sessionNewDocuments = require('./helpers/symbols').sessionNewDocuments;
>>>>>>> origin/wsj

let DocumentArray;
let MongooseArray;
let Embedded;

const specialProperties = utils.specialProperties;

<<<<<<< HEAD
/**
 * The core Mongoose document constructor. You should not call this directly,
 * the Mongoose [Model constructor](./api.html#Model) calls this for you.
=======
const VERSION_WHERE = 1;
const VERSION_INC = 2;
const VERSION_ALL = VERSION_WHERE | VERSION_INC;

/**
 * The core Mongoose document constructor. You should not call this directly,
 * the Mongoose [Model constructor](./api/model.html#Model) calls this for you.
>>>>>>> origin/wsj
 *
 * @param {Object} obj the values to set
 * @param {Object} [fields] optional object containing the fields which were selected in the query returning this document and any populated paths data
 * @param {Object} [options] various configuration options for the document
 * @param {Boolean} [options.defaults=true] if `false`, skip applying default values to this document.
<<<<<<< HEAD
 * @inherits NodeJS EventEmitter http://nodejs.org/api/events.html#events_class_events_eventemitter
=======
 * @inherits NodeJS EventEmitter https://nodejs.org/api/events.html#class-eventemitter
>>>>>>> origin/wsj
 * @event `init`: Emitted on a document after it has been retrieved from the db and fully hydrated by Mongoose.
 * @event `save`: Emitted when the document is successfully saved
 * @api private
 */

function Document(obj, fields, skipId, options) {
  if (typeof skipId === 'object' && skipId != null) {
    options = skipId;
    skipId = options.skipId;
  }
  options = Object.assign({}, options);
<<<<<<< HEAD
  const defaults = get(options, 'defaults', true);
  options.defaults = defaults;
=======

>>>>>>> origin/wsj
  // Support `browserDocument.js` syntax
  if (this.$__schema == null) {
    const _schema = utils.isObject(fields) && !fields.instanceOfSchema ?
      new Schema(fields) :
      fields;
    this.$__setSchema(_schema);
    fields = skipId;
    skipId = options;
    options = arguments[4] || {};
  }

<<<<<<< HEAD
  this.$__ = new InternalCache;
  this.$__.emitter = new EventEmitter();
  this.isNew = 'isNew' in options ? options.isNew : true;
  this.errors = undefined;
  this.$__.$options = options || {};
  this.$locals = {};
  this.$op = null;
=======
  this.$__ = new InternalCache();

  // Avoid setting `isNew` to `true`, because it is `true` by default
  if (options.isNew != null && options.isNew !== true) {
    this.$isNew = options.isNew;
  }

  if (options.priorDoc != null) {
    this.$__.priorDoc = options.priorDoc;
  }

  if (skipId) {
    this.$__.skipId = skipId;
  }

>>>>>>> origin/wsj
  if (obj != null && typeof obj !== 'object') {
    throw new ObjectParameterError(obj, 'obj', 'Document');
  }

<<<<<<< HEAD
  const schema = this.$__schema;

  if (typeof fields === 'boolean' || fields === 'throw') {
    this.$__.strictMode = fields;
    fields = undefined;
  } else {
    this.$__.strictMode = schema.options.strict;
    this.$__.selected = fields;
=======
  let defaults = true;
  if (options.defaults !== undefined) {
    this.$__.defaults = options.defaults;
    defaults = options.defaults;
  }

  const schema = this.$__schema;

  if (typeof fields === 'boolean' || fields === 'throw') {
    if (fields !== true) {
      this.$__.strictMode = fields;
    }
    fields = undefined;
  } else if (schema.options.strict !== true) {
    this.$__.strictMode = schema.options.strict;
>>>>>>> origin/wsj
  }

  const requiredPaths = schema.requiredPaths(true);
  for (const path of requiredPaths) {
    this.$__.activePaths.require(path);
  }

<<<<<<< HEAD
  this.$__.emitter.setMaxListeners(0);

=======
>>>>>>> origin/wsj
  let exclude = null;

  // determine if this doc is a result of a query with
  // excluded fields
<<<<<<< HEAD
  if (utils.isPOJO(fields)) {
    exclude = isExclusive(fields);
=======
  if (utils.isPOJO(fields) && Object.keys(fields).length > 0) {
    exclude = isExclusive(fields);
    this.$__.selected = fields;
    this.$__.exclude = exclude;
>>>>>>> origin/wsj
  }

  const hasIncludedChildren = exclude === false && fields ?
    $__hasIncludedChildren(fields) :
<<<<<<< HEAD
    {};
=======
    null;
>>>>>>> origin/wsj

  if (this._doc == null) {
    this.$__buildDoc(obj, fields, skipId, exclude, hasIncludedChildren, false);

    // By default, defaults get applied **before** setting initial values
    // Re: gh-6155
    if (defaults) {
<<<<<<< HEAD
      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, true, {
        isNew: this.isNew
=======
      applyDefaults(this, fields, exclude, hasIncludedChildren, true, null, {
        skipParentChangeTracking: true
>>>>>>> origin/wsj
      });
    }
  }
  if (obj) {
    // Skip set hooks
    if (this.$__original_set) {
<<<<<<< HEAD
      this.$__original_set(obj, undefined, true);
    } else {
      this.$set(obj, undefined, true);
    }

    if (obj instanceof Document) {
      this.isNew = obj.isNew;
=======
      this.$__original_set(obj, undefined, true, options);
    } else {
      this.$set(obj, undefined, true, options);
    }

    if (obj instanceof Document) {
      this.$isNew = obj.$isNew;
>>>>>>> origin/wsj
    }
  }

  // Function defaults get applied **after** setting initial values so they
  // see the full doc rather than an empty one, unless they opt out.
  // Re: gh-3781, gh-6155
  if (options.willInit && defaults) {
<<<<<<< HEAD
    EventEmitter.prototype.once.call(this, 'init', () => {
      $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
        isNew: this.isNew
      });
    });
  } else if (defaults) {
    $__applyDefaults(this, fields, skipId, exclude, hasIncludedChildren, false, options.skipDefaults, {
      isNew: this.isNew
    });
  }

  this.$__._id = this._id;

=======
    if (options.skipDefaults) {
      this.$__.skipDefaults = options.skipDefaults;
    }
  } else if (defaults) {
    applyDefaults(this, fields, exclude, hasIncludedChildren, false, options.skipDefaults);
  }

>>>>>>> origin/wsj
  if (!this.$__.strictMode && obj) {
    const _this = this;
    const keys = Object.keys(this._doc);

    keys.forEach(function(key) {
<<<<<<< HEAD
      if (!(key in schema.tree)) {
        defineKey(key, null, _this);
=======
      // Avoid methods, virtuals, existing fields, and `$` keys. The latter is to avoid overwriting
      // Mongoose internals.
      if (!(key in schema.tree) && !(key in schema.methods) && !(key in schema.virtuals) && !key.startsWith('$')) {
        defineKey({ prop: key, subprops: null, prototype: _this });
>>>>>>> origin/wsj
      }
    });
  }

  applyQueue(this);
}

<<<<<<< HEAD
=======
Document.prototype.$isMongooseDocumentPrototype = true;

/**
 * Boolean flag specifying if the document is new. If you create a document
 * using `new`, this document will be considered "new". `$isNew` is how
 * Mongoose determines whether `save()` should use `insertOne()` to create
 * a new document or `updateOne()` to update an existing document.
 *
 * #### Example:
 *
 *     const user = new User({ name: 'John Smith' });
 *     user.$isNew; // true
 *
 *     await user.save(); // Sends an `insertOne` to MongoDB
 *
 * On the other hand, if you load an existing document from the database
 * using `findOne()` or another [query operation](https://mongoosejs.com/docs/queries.html),
 * `$isNew` will be false.
 *
 * #### Example:
 *
 *     const user = await User.findOne({ name: 'John Smith' });
 *     user.$isNew; // false
 *
 * Mongoose sets `$isNew` to `false` immediately after `save()` succeeds.
 * That means Mongoose sets `$isNew` to false **before** `post('save')` hooks run.
 * In `post('save')` hooks, `$isNew` will be `false` if `save()` succeeded.
 *
 * #### Example:
 *
 *     userSchema.post('save', function() {
 *       this.$isNew; // false
 *     });
 *     await User.create({ name: 'John Smith' });
 *
 * For subdocuments, `$isNew` is true if either the parent has `$isNew` set,
 * or if you create a new subdocument.
 *
 * #### Example:
 *
 *     // Assume `Group` has a document array `users`
 *     const group = await Group.findOne();
 *     group.users[0].$isNew; // false
 *
 *     group.users.push({ name: 'John Smith' });
 *     group.users[1].$isNew; // true
 *
 * @api public
 * @property $isNew
 * @memberOf Document
 * @instance
 */

Object.defineProperty(Document.prototype, 'isNew', {
  get: function() {
    return this.$isNew;
  },
  set: function(value) {
    this.$isNew = value;
  }
});

/**
 * Hash containing current validation errors.
 *
 * @api public
 * @property errors
 * @memberOf Document
 * @instance
 */

Object.defineProperty(Document.prototype, 'errors', {
  get: function() {
    return this.$errors;
  },
  set: function(value) {
    this.$errors = value;
  }
});

/*!
 * ignore
 */

Document.prototype.$isNew = true;

>>>>>>> origin/wsj
/*!
 * Document exposes the NodeJS event emitter API, so you can use
 * `on`, `once`, etc.
 */
utils.each(
  ['on', 'once', 'emit', 'listeners', 'removeListener', 'setMaxListeners',
    'removeAllListeners', 'addListener'],
  function(emitterFn) {
    Document.prototype[emitterFn] = function() {
<<<<<<< HEAD
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
=======
      // Delay creating emitter until necessary because emitters take up a lot of memory,
      // especially for subdocuments.
      if (!this.$__.emitter) {
        if (emitterFn === 'emit') {
          return;
        }
        this.$__.emitter = new EventEmitter();
        this.$__.emitter.setMaxListeners(0);
      }
      return this.$__.emitter[emitterFn].apply(this.$__.emitter, arguments);
    };
    Document.prototype[`$${emitterFn}`] = Document.prototype[emitterFn];
>>>>>>> origin/wsj
  });

Document.prototype.constructor = Document;

for (const i in EventEmitter.prototype) {
  Document[i] = EventEmitter.prototype[i];
}

/**
 * The document's internal schema.
 *
 * @api private
 * @property schema
 * @memberOf Document
 * @instance
 */

Document.prototype.$__schema;

/**
 * The document's schema.
 *
 * @api public
 * @property schema
 * @memberOf Document
 * @instance
 */

Document.prototype.schema;

/**
 * Empty object that you can use for storing properties on the document. This
 * is handy for passing data to middleware without conflicting with Mongoose
 * internals.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     schema.pre('save', function() {
 *       // Mongoose will set `isNew` to `false` if `save()` succeeds
 *       this.$locals.wasNew = this.isNew;
 *     });
 *
 *     schema.post('save', function() {
 *       // Prints true if `isNew` was set before `save()`
 *       console.log(this.$locals.wasNew);
 *     });
 *
 * @api public
 * @property $locals
 * @memberOf Document
 * @instance
 */

Object.defineProperty(Document.prototype, '$locals', {
  configurable: false,
  enumerable: false,
<<<<<<< HEAD
  writable: true
});

/**
 * Boolean flag specifying if the document is new.
=======
  get: function() {
    if (this.$__.locals == null) {
      this.$__.locals = {};
    }
    return this.$__.locals;
  },
  set: function(v) {
    this.$__.locals = v;
  }
});

/**
 * Legacy alias for `$isNew`.
>>>>>>> origin/wsj
 *
 * @api public
 * @property isNew
 * @memberOf Document
<<<<<<< HEAD
=======
 * @see $isNew https://mongoosejs.com/docs/api/document.html#Document.prototype.$isNew
>>>>>>> origin/wsj
 * @instance
 */

Document.prototype.isNew;

/**
 * Set this property to add additional query filters when Mongoose saves this document and `isNew` is false.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     // Make sure `save()` never updates a soft deleted document.
 *     schema.pre('save', function() {
 *       this.$where = { isDeleted: false };
 *     });
 *
 * @api public
 * @property $where
 * @memberOf Document
 * @instance
 */

Object.defineProperty(Document.prototype, '$where', {
  configurable: false,
  enumerable: false,
  writable: true
});

/**
 * The string version of this documents _id.
 *
<<<<<<< HEAD
 * ####Note:
 *
 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](/docs/guide.html#id) of its `Schema` to false at construction time.
=======
 * #### Note:
 *
 * This getter exists on all documents by default. The getter can be disabled by setting the `id` [option](https://mongoosejs.com/docs/guide.html#id) of its `Schema` to false at construction time.
>>>>>>> origin/wsj
 *
 *     new Schema({ name: String }, { id: false });
 *
 * @api public
<<<<<<< HEAD
 * @see Schema options /docs/guide.html#options
=======
 * @see Schema options https://mongoosejs.com/docs/guide.html#options
>>>>>>> origin/wsj
 * @property id
 * @memberOf Document
 * @instance
 */

Document.prototype.id;

/**
<<<<<<< HEAD
 * Hash containing current validation errors.
 *
 * @api public
 * @property errors
=======
 * Hash containing current validation $errors.
 *
 * @api public
 * @property $errors
>>>>>>> origin/wsj
 * @memberOf Document
 * @instance
 */

<<<<<<< HEAD
Document.prototype.errors;
=======
Document.prototype.$errors;
>>>>>>> origin/wsj

/**
 * A string containing the current operation that Mongoose is executing
 * on this document. May be `null`, `'save'`, `'validate'`, or `'remove'`.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     const doc = new Model({ name: 'test' });
 *     doc.$op; // null
 *
 *     const promise = doc.save();
 *     doc.$op; // 'save'
 *
 *     await promise;
 *     doc.$op; // null
 *
 * @api public
 * @property $op
 * @memberOf Document
 * @instance
 */

<<<<<<< HEAD
Document.prototype.$op;
=======
Object.defineProperty(Document.prototype, '$op', {
  get: function() {
    return this.$__.op || null;
  },
  set: function(value) {
    this.$__.op = value;
  }
});
>>>>>>> origin/wsj

/*!
 * ignore
 */

<<<<<<< HEAD
function $__hasIncludedChildren(fields) {
  const hasIncludedChildren = {};
  const keys = Object.keys(fields);

  for (const key of keys) {
    const parts = key.split('.');
    const c = [];

    for (const part of parts) {
      c.push(part);
      hasIncludedChildren[c.join('.')] = 1;
    }
  }

  return hasIncludedChildren;
}

/*!
 * ignore
 */

function $__applyDefaults(doc, fields, skipId, exclude, hasIncludedChildren, isBeforeSetters, pathsToSkip) {
  const paths = Object.keys(doc.$__schema.paths);
  const plen = paths.length;

  for (let i = 0; i < plen; ++i) {
    let def;
    let curPath = '';
    const p = paths[i];

    if (p === '_id' && skipId) {
=======
function $applyDefaultsToNested(val, path, doc) {
  if (val == null) {
    return;
  }

  const paths = Object.keys(doc.$__schema.paths);
  const plen = paths.length;

  const pathPieces = path.indexOf('.') === -1 ? [path] : path.split('.');

  for (let i = 0; i < plen; ++i) {
    let curPath = '';
    const p = paths[i];

    if (!p.startsWith(path + '.')) {
>>>>>>> origin/wsj
      continue;
    }

    const type = doc.$__schema.paths[p];
<<<<<<< HEAD
    const path = type.splitPath();
    const len = path.length;
    let included = false;
    let doc_ = doc._doc;
    for (let j = 0; j < len; ++j) {
      if (doc_ == null) {
        break;
      }

      const piece = path[j];
      curPath += (!curPath.length ? '' : '.') + piece;

      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (j === len - 1) {
        if (doc_[piece] !== void 0) {
          break;
        }

        if (typeof type.defaultValue === 'function') {
          if (!type.defaultValue.$runBeforeSetters && isBeforeSetters) {
            break;
          }
          if (type.defaultValue.$runBeforeSetters && !isBeforeSetters) {
            break;
          }
        } else if (!isBeforeSetters) {
          // Non-function defaults should always run **before** setters
          continue;
        }

        if (pathsToSkip && pathsToSkip[curPath]) {
          break;
        }

        if (fields && exclude !== null) {
          if (exclude === true) {
            // apply defaults to all non-excluded fields
            if (p in fields) {
              continue;
            }

            try {
              def = type.getDefault(doc, false);
            } catch (err) {
              doc.invalidate(p, err);
              break;
            }

            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          } else if (included) {
            // selected field
            try {
              def = type.getDefault(doc, false);
            } catch (err) {
              doc.invalidate(p, err);
              break;
            }

            if (typeof def !== 'undefined') {
              doc_[piece] = def;
              doc.$__.activePaths.default(p);
            }
          }
        } else {
          try {
            def = type.getDefault(doc, false);
          } catch (err) {
            doc.invalidate(p, err);
            break;
          }

          if (typeof def !== 'undefined') {
            doc_[piece] = def;
            doc.$__.activePaths.default(p);
          }
        }
      } else {
        doc_ = doc_[piece];
      }
=======
    const pieces = type.splitPath().slice(pathPieces.length);
    const len = pieces.length;

    if (type.defaultValue === void 0) {
      continue;
    }

    let cur = val;

    for (let j = 0; j < len; ++j) {
      if (cur == null) {
        break;
      }

      const piece = pieces[j];

      if (j === len - 1) {
        if (cur[piece] !== void 0) {
          break;
        }

        try {
          const def = type.getDefault(doc, false);
          if (def !== void 0) {
            cur[piece] = def;
          }
        } catch (err) {
          doc.invalidate(path + '.' + curPath, err);
          break;
        }

        break;
      }

      curPath += (!curPath.length ? '' : '.') + piece;

      cur[piece] = cur[piece] || {};
      cur = cur[piece];
>>>>>>> origin/wsj
    }
  }
}

/**
 * Builds the default doc structure
 *
 * @param {Object} obj
 * @param {Object} [fields]
 * @param {Boolean} [skipId]
<<<<<<< HEAD
=======
 * @param {Boolean} [exclude]
 * @param {Object} [hasIncludedChildren]
>>>>>>> origin/wsj
 * @api private
 * @method $__buildDoc
 * @memberOf Document
 * @instance
 */

Document.prototype.$__buildDoc = function(obj, fields, skipId, exclude, hasIncludedChildren) {
  const doc = {};

  const paths = Object.keys(this.$__schema.paths).
    // Don't build up any paths that are underneath a map, we don't know
    // what the keys will be
    filter(p => !p.includes('$*'));
  const plen = paths.length;
  let ii = 0;

  for (; ii < plen; ++ii) {
    const p = paths[ii];

    if (p === '_id') {
      if (skipId) {
        continue;
      }
      if (obj && '_id' in obj) {
        continue;
      }
    }

    const path = this.$__schema.paths[p].splitPath();
    const len = path.length;
    const last = len - 1;
    let curPath = '';
    let doc_ = doc;
    let included = false;

    for (let i = 0; i < len; ++i) {
      const piece = path[i];

<<<<<<< HEAD
      curPath += (!curPath.length ? '' : '.') + piece;
=======
      if (!curPath.length) {
        curPath = piece;
      } else {
        curPath += '.' + piece;
      }
>>>>>>> origin/wsj

      // support excluding intermediary levels
      if (exclude === true) {
        if (curPath in fields) {
          break;
        }
      } else if (exclude === false && fields && !included) {
        if (curPath in fields) {
          included = true;
        } else if (!hasIncludedChildren[curPath]) {
          break;
        }
      }

      if (i < last) {
        doc_ = doc_[piece] || (doc_[piece] = {});
      }
    }
  }

  this._doc = doc;
};

/*!
 * Converts to POJO when you use the document for querying
 */

Document.prototype.toBSON = function() {
  return this.toObject(internalToObjectOptions);
};

/**
<<<<<<< HEAD
 * Initializes the document without setters or marking anything modified.
 *
 * Called internally after a document is returned from mongodb. Normally,
 * you do **not** need to call this function on your own.
 *
 * This function triggers `init` [middleware](/docs/middleware.html).
 * Note that `init` hooks are [synchronous](/docs/middleware.html#synchronous).
 *
 * @param {Object} doc document returned by mongo
=======
 * Hydrates this document with the data in `doc`. Does not run setters or mark any paths modified.
 *
 * Called internally after a document is returned from MongoDB. Normally,
 * you do **not** need to call this function on your own.
 *
 * This function triggers `init` [middleware](https://mongoosejs.com/docs/middleware.html).
 * Note that `init` hooks are [synchronous](https://mongoosejs.com/docs/middleware.html#synchronous).
 *
 * @param {Object} doc raw document returned by mongo
 * @param {Object} [opts]
 * @param {Boolean} [opts.hydratedPopulatedDocs=false] If true, hydrate and mark as populated any paths that are populated in the raw document
 * @param {Function} [fn]
>>>>>>> origin/wsj
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.init = function(doc, opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = null;
  }

  this.$__init(doc, opts);

  if (fn) {
    fn(null, this);
  }

  return this;
};

<<<<<<< HEAD
/*!
 * ignore
 */

Document.prototype.$__init = function(doc, opts) {
  this.isNew = false;
  this.$init = true;
=======
/**
 * Alias for [`.init`](https://mongoosejs.com/docs/api/document.html#Document.prototype.init())
 *
 * @api public
 */

Document.prototype.$init = function() {
  return this.constructor.prototype.init.apply(this, arguments);
};

/**
 * Internal "init" function
 *
 * @param {Document} doc
 * @param {Object} [opts]
 * @returns {Document} this
 * @api private
 */

Document.prototype.$__init = function(doc, opts) {
  this.$isNew = false;
>>>>>>> origin/wsj
  opts = opts || {};

  // handle docs with populated paths
  // If doc._id is not null or undefined
  if (doc._id != null && opts.populated && opts.populated.length) {
    const id = String(doc._id);
    for (const item of opts.populated) {
      if (item.isVirtual) {
<<<<<<< HEAD
        this.populated(item.path, utils.getValue(item.path, doc), item);
      } else {
        this.populated(item.path, item._docs[id], item);
=======
        this.$populated(item.path, utils.getValue(item.path, doc), item);
      } else {
        this.$populated(item.path, item._docs[id], item);
>>>>>>> origin/wsj
      }

      if (item._childDocs == null) {
        continue;
      }
      for (const child of item._childDocs) {
        if (child == null || child.$__ == null) {
          continue;
        }
        child.$__.parent = this;
      }
      item._childDocs = [];
    }
  }

  init(this, doc, this._doc, opts);

  markArraySubdocsPopulated(this, opts.populated);
<<<<<<< HEAD

  this.emit('init', this);
  this.constructor.emit('init', this);

  this.$__._id = this._id;
  return this;
};

/*!
 * If populating a path within a document array, make sure each
 * subdoc within the array knows its subpaths are populated.
 *
 * ####Example:
 *     const doc = await Article.findOne().populate('comments.author');
 *     doc.comments[0].populated('author'); // Should be set
 */

function markArraySubdocsPopulated(doc, populated) {
  if (doc._id == null || populated == null || populated.length === 0) {
    return;
  }

  const id = String(doc._id);
  for (const item of populated) {
    if (item.isVirtual) {
      continue;
    }
    const path = item.path;
    const pieces = path.split('.');
    for (let i = 0; i < pieces.length - 1; ++i) {
      const subpath = pieces.slice(0, i + 1).join('.');
      const rest = pieces.slice(i + 1).join('.');
      const val = doc.get(subpath);
      if (val == null) {
        continue;
      }

      if (val.isMongooseDocumentArray) {
        for (let j = 0; j < val.length; ++j) {
          val[j].populated(rest, item._docs[id] == null ? [] : item._docs[id][j], item);
        }
        break;
      }
    }
  }
}

/*!
=======
  this.$emit('init', this);
  this.constructor.emit('init', this);

  const hasIncludedChildren = this.$__.exclude === false && this.$__.selected ?
    $__hasIncludedChildren(this.$__.selected) :
    null;

  applyDefaults(this, this.$__.selected, this.$__.exclude, hasIncludedChildren, false, this.$__.skipDefaults);
  return this;
};

/**
>>>>>>> origin/wsj
 * Init helper.
 *
 * @param {Object} self document instance
 * @param {Object} obj raw mongodb doc
 * @param {Object} doc object we are initializing
<<<<<<< HEAD
=======
 * @param {Object} [opts] Optional Options
 * @param {Boolean} [opts.setters] Call `applySetters` instead of `cast`
 * @param {String} [prefix] Prefix to add to each path
>>>>>>> origin/wsj
 * @api private
 */

function init(self, obj, doc, opts, prefix) {
  prefix = prefix || '';

<<<<<<< HEAD
  const keys = Object.keys(obj);
  const len = keys.length;
  let schema;
  let path;
  let i;
  let index = 0;
=======
  if (obj.$__ != null) {
    obj = obj._doc;
  }
  const keys = Object.keys(obj);
  const len = keys.length;
  let schemaType;
  let path;
  let i;
  let index = 0;
  const strict = self.$__.strictMode;
  const docSchema = self.$__schema;
>>>>>>> origin/wsj

  while (index < len) {
    _init(index++);
  }

  function _init(index) {
    i = keys[index];
<<<<<<< HEAD
    path = prefix + i;
    schema = self.$__schema.path(path);

    // Should still work if not a model-level discriminator, but should not be
    // necessary. This is *only* to catch the case where we queried using the
    // base model and the discriminated model has a projection
    if (self.$__schema.$isRootDiscriminator && !self.$__isSelected(path)) {
      return;
    }

    if (!schema && utils.isPOJO(obj[i])) {
      // assume nested object
      if (!doc[i]) {
        doc[i] = {};
      }
      init(self, obj[i], doc[i], opts, path + '.');
    } else if (!schema) {
      doc[i] = obj[i];
    } else {
      if (obj[i] === null) {
        doc[i] = schema._castNullish(null);
      } else if (obj[i] !== undefined) {
        const intCache = obj[i].$__ || {};
        const wasPopulated = intCache.wasPopulated || null;

        if (schema && !wasPopulated) {
          try {
            doc[i] = schema.cast(obj[i], self, true);
=======
    // avoid prototype pollution
    if (i === '__proto__' || i === 'constructor') {
      return;
    }
    path = prefix ? prefix + i : i;
    schemaType = docSchema.path(path);
    // Should still work if not a model-level discriminator, but should not be
    // necessary. This is *only* to catch the case where we queried using the
    // base model and the discriminated model has a projection
    if (docSchema.$isRootDiscriminator && !self.$__isSelected(path)) {
      return;
    }

    const value = obj[i];
    if (!schemaType && utils.isPOJO(value)) {
      // assume nested object
      if (!doc[i]) {
        doc[i] = {};
        if (!strict && !(i in docSchema.tree) && !(i in docSchema.methods) && !(i in docSchema.virtuals)) {
          self[i] = doc[i];
        }
      }
      init(self, value, doc[i], opts, path + '.');
    } else if (!schemaType) {
      doc[i] = value;
      if (!strict && !prefix) {
        self[i] = value;
      }
    } else {
      // Retain order when overwriting defaults
      if (doc.hasOwnProperty(i) && value !== void 0 && !opts.hydratedPopulatedDocs) {
        delete doc[i];
      }
      if (value === null) {
        doc[i] = schemaType._castNullish(null);
      } else if (value !== undefined) {
        const wasPopulated = value.$__ == null ? null : value.$__.wasPopulated;

        if (schemaType && !wasPopulated && !opts.hydratedPopulatedDocs) {
          try {
            if (opts && opts.setters) {
              // Call applySetters with `init = false` because otherwise setters are a noop
              const overrideInit = false;
              doc[i] = schemaType.applySetters(value, self, overrideInit);
            } else {
              doc[i] = schemaType.cast(value, self, true);
            }
>>>>>>> origin/wsj
          } catch (e) {
            self.invalidate(e.path, new ValidatorError({
              path: e.path,
              message: e.message,
              type: 'cast',
              value: e.value,
              reason: e
            }));
          }
<<<<<<< HEAD
        } else {
          doc[i] = obj[i];
        }
      }
      // mark as hydrated
      if (!self.isModified(path)) {
=======
        } else if (opts.hydratedPopulatedDocs) {
          doc[i] = schemaType.cast(value, self, true);

          if (doc[i] && doc[i].$__ && doc[i].$__.wasPopulated) {
            self.$populated(path, doc[i].$__.wasPopulated.value, doc[i].$__.wasPopulated.options);
          } else if (Array.isArray(doc[i]) && doc[i].length && doc[i][0]?.$__?.wasPopulated) {
            self.$populated(path, doc[i].map(populatedDoc => populatedDoc?.$__?.wasPopulated?.value).filter(val => val != null), doc[i][0].$__.wasPopulated.options);
          }
        } else {
          doc[i] = value;
        }
      }
      // mark as hydrated
      if (!self.$isModified(path)) {
>>>>>>> origin/wsj
        self.$__.activePaths.init(path);
      }
    }
  }
}

/**
<<<<<<< HEAD
 * Sends an update command with this document `_id` as the query selector.
 *
 * ####Example:
 *
 *     weirdCar.update({$inc: {wheels:1}}, { w: 1 }, callback);
 *
 * ####Valid options:
 *
 *  - same as in [Model.update](#model_Model.update)
 *
 * @see Model.update #model_Model.update
 * @param {Object} doc
 * @param {Object} options
 * @param {Function} callback
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.update = function update() {
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
  const query = this.constructor.update.apply(this.constructor, args);

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  return query;
};

/**
 * Sends an updateOne command with this document `_id` as the query selector.
 *
 * ####Example:
 *
 *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 }, callback);
 *
 * ####Valid options:
 *
 *  - same as in [Model.updateOne](#model_Model.updateOne)
 *
 * @see Model.updateOne #model_Model.updateOne
 * @param {Object} doc
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](http://mongoosejs.com/docs/api.html#query_Query-setOptions)
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](/docs/api.html#query_Query-lean) and the [Mongoose lean tutorial](/docs/tutorials/lean.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](http://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.omitUndefined=false] If true, delete any properties whose value is `undefined` when casting an update. In other words, if this is set, Mongoose will delete `baz` from the update in `Model.updateOne({}, { foo: 'bar', baz: undefined })` before sending the update to the server.
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
 * @param {Function} callback
=======
 * Sends an updateOne command with this document `_id` as the query selector.
 *
 * #### Example:
 *
 *     weirdCar.updateOne({$inc: {wheels:1}}, { w: 1 });
 *
 * #### Valid options:
 *
 *  - same as in [Model.updateOne](https://mongoosejs.com/docs/api/model.html#Model.updateOne)
 *
 * @see Model.updateOne https://mongoosejs.com/docs/api/model.html#Model.updateOne
 * @param {Object} doc
 * @param {Object} [options] optional see [`Query.prototype.setOptions()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.setOptions())
 * @param {Object} [options.lean] if truthy, mongoose will return the document as a plain JavaScript object rather than a mongoose document. See [`Query.lean()`](https://mongoosejs.com/docs/api/query.html#Query.prototype.lean()) and the [Mongoose lean tutorial](https://mongoosejs.com/docs/tutorials/lean.html).
 * @param {Boolean|String} [options.strict] overwrites the schema's [strict mode option](https://mongoosejs.com/docs/guide.html#strict)
 * @param {Boolean} [options.timestamps=null] If set to `false` and [schema-level timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this update. Note that this allows you to overwrite timestamps. Does nothing if schema-level timestamps are not set.
>>>>>>> origin/wsj
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.updateOne = function updateOne(doc, options, callback) {
<<<<<<< HEAD
  const query = this.constructor.updateOne({ _id: this._id }, doc, options);
  query.pre(cb => {
    this.constructor._middleware.execPre('updateOne', this, [this], cb);
  });
  query.post(cb => {
    this.constructor._middleware.execPost('updateOne', this, [this], {}, cb);
=======
  const query = this.constructor.updateOne({ _id: this._doc._id }, doc, options);
  const self = this;
  query.pre(function queryPreUpdateOne(cb) {
    self.constructor._middleware.execPre('updateOne', self, [self], cb);
  });
  query.post(function queryPostUpdateOne(cb) {
    self.constructor._middleware.execPost('updateOne', self, [self], {}, cb);
>>>>>>> origin/wsj
  });

  if (this.$session() != null) {
    if (!('session' in query.options)) {
      query.options.session = this.$session();
    }
  }

  if (callback != null) {
    return query.exec(callback);
  }

  return query;
};

/**
 * Sends a replaceOne command with this document `_id` as the query selector.
 *
<<<<<<< HEAD
 * ####Valid options:
 *
 *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#model_Model.replaceOne)
 *
 * @see Model.replaceOne #model_Model.replaceOne
 * @param {Object} doc
 * @param {Object} options
 * @param {Function} callback
=======
 * #### Valid options:
 *
 *  - same as in [Model.replaceOne](https://mongoosejs.com/docs/api/model.html#Model.replaceOne())
 *
 * @see Model.replaceOne https://mongoosejs.com/docs/api/model.html#Model.replaceOne()
 * @param {Object} doc
 * @param {Object} [options]
 * @param {Function} [callback]
>>>>>>> origin/wsj
 * @return {Query}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.replaceOne = function replaceOne() {
<<<<<<< HEAD
  const args = utils.args(arguments);
  args.unshift({ _id: this._id });
=======
  const args = [...arguments];
  args.unshift({ _id: this._doc._id });
>>>>>>> origin/wsj
  return this.constructor.replaceOne.apply(this.constructor, args);
};

/**
 * Getter/setter around the session associated with this document. Used to
 * automatically set `session` if you `save()` a doc that you got from a
 * query with an associated session.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     const session = MyModel.startSession();
 *     const doc = await MyModel.findOne().session(session);
 *     doc.$session() === session; // true
 *     doc.$session(null);
 *     doc.$session() === null; // true
 *
 * If this is a top-level document, setting the session propagates to all child
 * docs.
 *
 * @param {ClientSession} [session] overwrite the current session
 * @return {ClientSession}
 * @method $session
 * @api public
 * @memberOf Document
 */

Document.prototype.$session = function $session(session) {
  if (arguments.length === 0) {
    if (this.$__.session != null && this.$__.session.hasEnded) {
      this.$__.session = null;
      return null;
    }
    return this.$__.session;
  }

  if (session != null && session.hasEnded) {
    throw new MongooseError('Cannot set a document\'s session to a session that has ended. Make sure you haven\'t ' +
      'called `endSession()` on the session you are passing to `$session()`.');
  }

<<<<<<< HEAD
  this.$__.session = session;

  if (!this.ownerDocument) {
=======
  if (session == null && this.$__.session == null) {
    return;
  }

  this.$__.session = session;

  if (!this.$isSubdocument) {
>>>>>>> origin/wsj
    const subdocs = this.$getAllSubdocs();
    for (const child of subdocs) {
      child.$session(session);
    }
  }

  return session;
};

/**
<<<<<<< HEAD
=======
 * Getter/setter around whether this document will apply timestamps by
 * default when using `save()` and `bulkSave()`.
 *
 * #### Example:
 *
 *     const TestModel = mongoose.model('Test', new Schema({ name: String }, { timestamps: true }));
 *     const doc = new TestModel({ name: 'John Smith' });
 *
 *     doc.$timestamps(); // true
 *
 *     doc.$timestamps(false);
 *     await doc.save(); // Does **not** apply timestamps
 *
 * @param {Boolean} [value] overwrite the current session
 * @return {Document|boolean|undefined} When used as a getter (no argument), a boolean will be returned indicating the timestamps option state or if unset "undefined" will be used, otherwise will return "this"
 * @method $timestamps
 * @api public
 * @memberOf Document
 */

Document.prototype.$timestamps = function $timestamps(value) {
  if (arguments.length === 0) {
    if (this.$__.timestamps != null) {
      return this.$__.timestamps;
    }

    if (this.$__schema) {
      return this.$__schema.options.timestamps;
    }

    return undefined;
  }

  const currentValue = this.$timestamps();
  if (value !== currentValue) {
    this.$__.timestamps = value;
  }

  return this;
};

/**
>>>>>>> origin/wsj
 * Overwrite all values in this document with the values of `obj`, except
 * for immutable properties. Behaves similarly to `set()`, except for it
 * unsets all properties that aren't in `obj`.
 *
 * @param {Object} obj the object to overwrite this document with
 * @method overwrite
<<<<<<< HEAD
 * @name overwrite
 * @memberOf Document
 * @instance
 * @api public
=======
 * @memberOf Document
 * @instance
 * @api public
 * @return {Document} this
>>>>>>> origin/wsj
 */

Document.prototype.overwrite = function overwrite(obj) {
  const keys = Array.from(new Set(Object.keys(this._doc).concat(Object.keys(obj))));

  for (const key of keys) {
    if (key === '_id') {
      continue;
    }
    // Explicitly skip version key
    if (this.$__schema.options.versionKey && key === this.$__schema.options.versionKey) {
      continue;
    }
    if (this.$__schema.options.discriminatorKey && key === this.$__schema.options.discriminatorKey) {
      continue;
    }
    this.$set(key, obj[key]);
  }

  return this;
};

/**
 * Alias for `set()`, used internally to avoid conflicts
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
<<<<<<< HEAD
 * @method $set
 * @name $set
=======
 * @param {Boolean} [options.merge=false] if true, setting a [nested path](https://mongoosejs.com/docs/subdocs.html#subdocuments-versus-nested-paths) will merge existing values rather than overwrite the whole object. So `doc.set('nested', { a: 1, b: 2 })` becomes `doc.set('nested.a', 1); doc.set('nested.b', 2);`
 * @return {Document} this
 * @method $set
>>>>>>> origin/wsj
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$set = function $set(path, val, type, options) {
  if (utils.isPOJO(type)) {
    options = type;
    type = undefined;
  }

<<<<<<< HEAD
  options = options || {};
  const merge = options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
  const typeKey = this.$__schema.options.typeKey;
=======
  const merge = options && options.merge;
  const adhoc = type && type !== true;
  const constructing = type === true;
>>>>>>> origin/wsj
  let adhocs;
  let keys;
  let i = 0;
  let pathtype;
  let key;
  let prefix;

<<<<<<< HEAD
  const strict = 'strict' in options
=======
  const userSpecifiedStrict = options && 'strict' in options;
  let strict = userSpecifiedStrict
>>>>>>> origin/wsj
    ? options.strict
    : this.$__.strictMode;

  if (adhoc) {
    adhocs = this.$__.adhocPaths || (this.$__.adhocPaths = {});
    adhocs[path] = this.$__schema.interpretAsType(path, type, this.$__schema.options);
  }

  if (path == null) {
<<<<<<< HEAD
    const _ = path;
    path = val;
    val = _;
=======
    [path, val] = [val, path];
>>>>>>> origin/wsj
  } else if (typeof path !== 'string') {
    // new Document({ key: val })
    if (path instanceof Document) {
      if (path.$__isNested) {
        path = path.toObject();
      } else {
<<<<<<< HEAD
        path = path._doc;
      }
    }
    if (path == null) {
      const _ = path;
      path = val;
      val = _;
    }

    prefix = val ? val + '.' : '';
    keys = Object.keys(path);
=======
        // This ternary is to support gh-7898 (copying virtuals if same schema)
        // while not breaking gh-10819, which for some reason breaks if we use toObject()
        path = path.$__schema === this.$__schema
          ? applyVirtuals(path, { ...path._doc })
          : path._doc;
      }
    }
    if (path == null) {
      [path, val] = [val, path];
    }

    prefix = val ? val + '.' : '';
    keys = getKeysInSchemaOrder(this.$__schema, path);

>>>>>>> origin/wsj
    const len = keys.length;

    // `_skipMinimizeTopLevel` is because we may have deleted the top-level
    // nested key to ensure key order.
<<<<<<< HEAD
    const _skipMinimizeTopLevel = get(options, '_skipMinimizeTopLevel', false);
=======
    const _skipMinimizeTopLevel = options && options._skipMinimizeTopLevel || false;
>>>>>>> origin/wsj
    if (len === 0 && _skipMinimizeTopLevel) {
      delete options._skipMinimizeTopLevel;
      if (val) {
        this.$set(val, {});
      }
      return this;
    }

<<<<<<< HEAD
    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix + key;
      pathtype = this.$__schema.pathType(pathName);
=======
    options = Object.assign({}, options, { _skipMinimizeTopLevel: false });

    for (let i = 0; i < len; ++i) {
      key = keys[i];
      const pathName = prefix ? prefix + key : key;
      pathtype = this.$__schema.pathType(pathName);
      const valForKey = path[key];
>>>>>>> origin/wsj

      // On initial set, delete any nested keys if we're going to overwrite
      // them to ensure we keep the user's key order.
      if (type === true &&
          !prefix &&
<<<<<<< HEAD
          path[key] != null &&
          pathtype === 'nested' &&
          this._doc[key] != null &&
          Object.keys(this._doc[key]).length === 0) {
        delete this._doc[key];
        // Make sure we set `{}` back even if we minimize re: gh-8565
        options = Object.assign({}, options, { _skipMinimizeTopLevel: true });
      } else {
        // Make sure we set `{_skipMinimizeTopLevel: false}` if don't have overwrite: gh-10441
        options = Object.assign({}, options, { _skipMinimizeTopLevel: false });
      }

      const someCondition = typeof path[key] === 'object' &&
                            !utils.isNativeObject(path[key]) &&
                            !utils.isMongooseType(path[key]) &&
                            path[key] != null &&
                            pathtype !== 'virtual' &&
                            pathtype !== 'real' &&
                            pathtype !== 'adhocOrUndefined' &&
                            !(this.$__path(pathName) instanceof MixedSchema) &&
                            !(this.$__schema.paths[pathName] &&
                            this.$__schema.paths[pathName].options &&
                            this.$__schema.paths[pathName].options.ref);

      if (someCondition) {
        this.$__.$setCalled.add(prefix + key);
        this.$set(path[key], prefix + key, constructing, options);
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && path[key] === void 0 &&
            this.get(pathName) !== void 0) {
=======
          valForKey != null &&
          pathtype === 'nested' &&
          this._doc[key] != null) {
        delete this._doc[key];
      }

      if (utils.isNonBuiltinObject(valForKey) && pathtype === 'nested') {
        this.$set(pathName, valForKey, constructing, Object.assign({}, options, { _skipMarkModified: true }));
        $applyDefaultsToNested(this.$get(pathName), pathName, this);
        continue;
      } else if (strict) {
        // Don't overwrite defaults with undefined keys (gh-3981) (gh-9039)
        if (constructing && valForKey === void 0 &&
            this.$get(pathName) !== void 0) {
>>>>>>> origin/wsj
          continue;
        }

        if (pathtype === 'adhocOrUndefined') {
          pathtype = getEmbeddedDiscriminatorPath(this, pathName, { typeOnly: true });
        }

        if (pathtype === 'real' || pathtype === 'virtual') {
<<<<<<< HEAD
          // Check for setting single embedded schema to document (gh-3535)
          let p = path[key];
          if (this.$__schema.paths[pathName] &&
              this.$__schema.paths[pathName].$isSingleNested &&
              path[key] instanceof Document) {
            p = p.toObject({ virtuals: false, transform: false });
          }
          this.$set(prefix + key, p, constructing, options);
        } else if (pathtype === 'nested' && path[key] instanceof Document) {
          this.$set(prefix + key,
            path[key].toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, path[key]);
          } else {
            throw new StrictModeError(key);
          }
        }
      } else if (path[key] !== void 0) {
        this.$set(prefix + key, path[key], constructing, options);
      }
    }

    return this;
  } else {
    this.$__.$setCalled.add(path);
  }

  let pathType = this.$__schema.pathType(path);
  if (pathType === 'adhocOrUndefined') {
    pathType = getEmbeddedDiscriminatorPath(this, path, { typeOnly: true });
=======
          this.$set(pathName, valForKey, constructing, options);
        } else if (pathtype === 'nested' && valForKey instanceof Document) {
          this.$set(pathName,
            valForKey.toObject({ transform: false }), constructing, options);
        } else if (strict === 'throw') {
          if (pathtype === 'nested') {
            throw new ObjectExpectedError(key, valForKey);
          } else {
            throw new StrictModeError(key);
          }
        } else if (pathtype === 'nested' && valForKey == null) {
          this.$set(pathName, valForKey, constructing, options);
        }
      } else if (valForKey !== void 0) {
        this.$set(pathName, valForKey, constructing, options);
      }
    }

    // Ensure all properties are in correct order
    const orderedDoc = {};
    const orderedKeys = Object.keys(this.$__schema.tree);
    for (let i = 0, len = orderedKeys.length; i < len; ++i) {
      (key = orderedKeys[i]) &&
      (this._doc.hasOwnProperty(key)) &&
      (orderedDoc[key] = undefined);
    }
    this._doc = Object.assign(orderedDoc, this._doc);

    return this;
  }

  let pathType = this.$__schema.pathType(path);
  let parts = null;
  if (pathType === 'adhocOrUndefined') {
    parts = path.indexOf('.') === -1 ? [path] : path.split('.');
    pathType = getEmbeddedDiscriminatorPath(this, parts, { typeOnly: true });
  }
  if (pathType === 'adhocOrUndefined' && !userSpecifiedStrict) {
    // May be path underneath non-strict schema
    if (parts == null) {
      parts = path.indexOf('.') === -1 ? [path] : path.split('.');
    }
    const subdocStrict = getSubdocumentStrictValue(this.$__schema, parts);
    if (subdocStrict !== undefined) {
      strict = subdocStrict;
    }
>>>>>>> origin/wsj
  }

  // Assume this is a Mongoose document that was copied into a POJO using
  // `Object.assign()` or `{...doc}`
<<<<<<< HEAD
  val = handleSpreadDoc(val);

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      const hasPriorVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const priorVal = this.$__getValue(path);
        this.$__.savedState[path] = priorVal;

        const keys = Object.keys(priorVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = priorVal[key];
=======
  val = handleSpreadDoc(val, true);

  // if this doc is being constructed we should not trigger getters
  const priorVal = (() => {
    if (this.$__.priorDoc != null) {
      return this.$__.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (pathType === 'nested' && val) {
    if (typeof val === 'object' && val != null) {
      if (val.$__ != null) {
        val = val.toObject(internalToObjectOptions);
      }
      if (val == null) {
        this.invalidate(path, new MongooseError.CastError('Object', val, path));
        return this;
      }
      const wasModified = this.$isModified(path);
      const hasInitialVal = this.$__.savedState != null && this.$__.savedState.hasOwnProperty(path);
      if (this.$__.savedState != null && !this.$isNew && !this.$__.savedState.hasOwnProperty(path)) {
        const initialVal = this.$__getValue(path);
        this.$__.savedState[path] = initialVal;

        const keys = Object.keys(initialVal || {});
        for (const key of keys) {
          this.$__.savedState[path + '.' + key] = initialVal[key];
>>>>>>> origin/wsj
        }
      }

      if (!merge) {
        this.$__setValue(path, null);
        cleanModifiedSubpaths(this, path);
      } else {
<<<<<<< HEAD
        return this.$set(val, path, constructing);
      }

      const keys = Object.keys(val);
      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing);
      }

      if (hasPriorVal && utils.deepEqual(this.$__.savedState[path], val)) {
=======
        return this.$set(val, path, constructing, options);
      }

      const keys = getKeysInSchemaOrder(this.$__schema, val, path);

      this.$__setValue(path, {});
      for (const key of keys) {
        this.$set(path + '.' + key, val[key], constructing, { ...options, _skipMarkModified: true });
      }
      if (priorVal != null &&
          (!wasModified || hasInitialVal) &&
          utils.deepEqual(hasInitialVal ? this.$__.savedState[path] : priorVal, val)) {
>>>>>>> origin/wsj
        this.unmarkModified(path);
      } else {
        this.markModified(path);
      }
<<<<<<< HEAD
      cleanModifiedSubpaths(this, path, { skipDocArrays: true });
=======
>>>>>>> origin/wsj
      return this;
    }
    this.invalidate(path, new MongooseError.CastError('Object', val, path));
    return this;
  }

  let schema;
<<<<<<< HEAD
  const parts = path.indexOf('.') === -1 ? [path] : path.split('.');

  // Might need to change path for top-level alias
  if (typeof this.$__schema.aliases[parts[0]] == 'string') {
=======
  if (parts == null) {
    parts = path.indexOf('.') === -1 ? [path] : path.split('.');
  }

  // Might need to change path for top-level alias
  if (typeof this.$__schema.aliases[parts[0]] === 'string') {
>>>>>>> origin/wsj
    parts[0] = this.$__schema.aliases[parts[0]];
  }

  if (pathType === 'adhocOrUndefined' && strict) {
    // check for roots that are Mixed types
    let mixed;

    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');

      // If path is underneath a virtual, bypass everything and just set it.
      if (i + 1 < parts.length && this.$__schema.pathType(subpath) === 'virtual') {
        mpath.set(path, val, this);
        return this;
      }

      schema = this.$__schema.path(subpath);
      if (schema == null) {
        continue;
      }

      if (schema instanceof MixedSchema) {
        // allow changes to sub paths of mixed types
        mixed = true;
        break;
<<<<<<< HEAD
=======
      } else if (schema.$isSchemaMap && schema.$__schemaType instanceof MixedSchema && i < parts.length - 1) {
        // Map of mixed and not the last element in the path resolves to mixed
        mixed = true;
        schema = schema.$__schemaType;
        break;
>>>>>>> origin/wsj
      }
    }

    if (schema == null) {
      // Check for embedded discriminators
      schema = getEmbeddedDiscriminatorPath(this, path);
    }

    if (!mixed && !schema) {
      if (strict === 'throw') {
        throw new StrictModeError(path);
      }
      return this;
    }
  } else if (pathType === 'virtual') {
    schema = this.$__schema.virtualpath(path);
    schema.applySetters(val, this);
    return this;
  } else {
    schema = this.$__path(path);
  }

  // gh-4578, if setting a deeply nested path that doesn't exist yet, create it
  let cur = this._doc;
  let curPath = '';
  for (i = 0; i < parts.length - 1; ++i) {
    cur = cur[parts[i]];
<<<<<<< HEAD
    curPath += (curPath.length > 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoError: cannot use the part (nested of nested.num) to
=======
    curPath += (curPath.length !== 0 ? '.' : '') + parts[i];
    if (!cur) {
      this.$set(curPath, {});
      // Hack re: gh-5800. If nested field is not selected, it probably exists
      // so `MongoServerError: cannot use the part (nested of nested.num) to
>>>>>>> origin/wsj
      // traverse the element ({nested: null})` is not likely. If user gets
      // that error, its their fault for now. We should reconsider disallowing
      // modifying not selected paths for 6.x
      if (!this.$__isSelected(curPath)) {
        this.unmarkModified(curPath);
      }
      cur = this.$__getValue(curPath);
    }
  }

  let pathToMark;

  // When using the $set operator the path to the field must already exist.
  // Else mongodb throws: "LEFT_SUBFIELD only supports Object"

  if (parts.length <= 1) {
    pathToMark = path;
  } else {
<<<<<<< HEAD
    for (i = 0; i < parts.length; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');
      if (this.get(subpath, null, { getters: false }) === null) {
=======
    const len = parts.length;
    for (i = 0; i < len; ++i) {
      const subpath = parts.slice(0, i + 1).join('.');
      if (this.$get(subpath, null, { getters: false }) === null) {
>>>>>>> origin/wsj
        pathToMark = subpath;
        break;
      }
    }

    if (!pathToMark) {
      pathToMark = path;
    }
  }

<<<<<<< HEAD
  // if this doc is being constructed we should not trigger getters
  const priorVal = (() => {
    if (this.$__.$options.priorDoc != null) {
      return this.$__.$options.priorDoc.$__getValue(path);
    }
    if (constructing) {
      return void 0;
    }
    return this.$__getValue(path);
  })();

  if (!schema) {
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);
=======
  if (!schema) {
    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);

    if (pathType === 'nested' && val == null) {
      cleanModifiedSubpaths(this, path);
    }
>>>>>>> origin/wsj
    return this;
  }

  // If overwriting a subdocument path, make sure to clear out
  // any errors _before_ setting, so new errors that happen
  // get persisted. Re: #9080
  if (schema.$isSingleNested || schema.$isMongooseArray) {
    _markValidSubpaths(this, path);
  }

<<<<<<< HEAD
  if (schema.$isSingleNested && val != null && merge) {
=======
  if (val != null && merge && schema.$isSingleNested) {
>>>>>>> origin/wsj
    if (val instanceof Document) {
      val = val.toObject({ virtuals: false, transform: false });
    }
    const keys = Object.keys(val);
    for (const key of keys) {
      this.$set(path + '.' + key, val[key], constructing, options);
    }

    return this;
  }

  let shouldSet = true;
  try {
    // If the user is trying to set a ref path to a document with
    // the correct model name, treat it as populated
    const refMatches = (() => {
      if (schema.options == null) {
        return false;
      }
      if (!(val instanceof Document)) {
        return false;
      }
      const model = val.constructor;

      // Check ref
<<<<<<< HEAD
      const ref = schema.options.ref;
=======
      const refOpt = typeof schema.options.ref === 'function' && !schema.options.ref[modelSymbol] ? schema.options.ref.call(this, this) : schema.options.ref;

      const ref = refOpt?.modelName || refOpt;
>>>>>>> origin/wsj
      if (ref != null && (ref === model.modelName || ref === model.baseModelName)) {
        return true;
      }

      // Check refPath
      const refPath = schema.options.refPath;
      if (refPath == null) {
        return false;
      }
      const modelName = val.get(refPath);
      return modelName === model.modelName || modelName === model.baseModelName;
    })();

    let didPopulate = false;
<<<<<<< HEAD
    if (refMatches && val instanceof Document) {
      this.populated(path, val._id, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = true;
=======
    if (refMatches && val instanceof Document && (!val.$__.wasPopulated || utils.deepEqual(val.$__.wasPopulated.value, val._doc._id))) {
      const unpopulatedValue = (schema && schema.$isSingleNested) ? schema.cast(val, this) : val._doc._id;
      this.$populated(path, unpopulatedValue, { [populateModelSymbol]: val.constructor });
      val.$__.wasPopulated = { value: unpopulatedValue };
>>>>>>> origin/wsj
      didPopulate = true;
    }

    let popOpts;
<<<<<<< HEAD
    if (schema.options &&
        Array.isArray(schema.options[typeKey]) &&
        schema.options[typeKey].length &&
        schema.options[typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
      popOpts = { [populateModelSymbol]: val[0].constructor };
      this.populated(path, val.map(function(v) { return v._id; }), popOpts);

      for (const doc of val) {
        doc.$__.wasPopulated = true;
=======
    const typeKey = this.$__schema.options.typeKey;
    if (schema.options &&
        Array.isArray(schema.options[typeKey]) &&
        schema.options[typeKey].length &&
        schema.options[typeKey][0] &&
        schema.options[typeKey][0].ref &&
        _isManuallyPopulatedArray(val, schema.options[typeKey][0].ref)) {
      popOpts = { [populateModelSymbol]: val[0].constructor };
      this.$populated(path, val.map(function(v) { return v._doc._id; }), popOpts);

      for (const doc of val) {
        doc.$__.wasPopulated = { value: doc._doc._id };
>>>>>>> origin/wsj
      }
      didPopulate = true;
    }

<<<<<<< HEAD
    if (this.$__schema.singleNestedPaths[path] == null) {
=======
    if (!refMatches || !schema.$isSingleNested || !val.$__) {
>>>>>>> origin/wsj
      // If this path is underneath a single nested schema, we'll call the setter
      // later in `$__set()` because we don't take `_doc` when we iterate through
      // a single nested doc. That's to make sure we get the correct context.
      // Otherwise we would double-call the setter, see gh-7196.
<<<<<<< HEAD
      val = schema.applySetters(val, this, false, priorVal);
    }

    if (schema.$isMongooseDocumentArray &&
        Array.isArray(val) &&
        val.length > 0 &&
=======
      let setterContext = this;
      if (this.$__schema.singleNestedPaths[path] != null && parts.length > 1) {
        setterContext = getDeepestSubdocumentForPath(this, parts, this.schema);
      }
      if (options != null && options.overwriteImmutable) {
        val = schema.applySetters(val, setterContext, false, priorVal, { overwriteImmutable: true });
      } else {
        val = schema.applySetters(val, setterContext, false, priorVal);
      }
    }

    if (Array.isArray(val) &&
        !Array.isArray(schema) &&
        schema.$isMongooseDocumentArray &&
        val.length !== 0 &&
>>>>>>> origin/wsj
        val[0] != null &&
        val[0].$__ != null &&
        val[0].$__.populated != null) {
      const populatedPaths = Object.keys(val[0].$__.populated);
      for (const populatedPath of populatedPaths) {
<<<<<<< HEAD
        this.populated(path + '.' + populatedPath,
          val.map(v => v.populated(populatedPath)),
=======
        this.$populated(path + '.' + populatedPath,
          val.map(v => v.$populated(populatedPath)),
>>>>>>> origin/wsj
          val[0].$__.populated[populatedPath].options);
      }
      didPopulate = true;
    }

    if (!didPopulate && this.$__.populated) {
      // If this array partially contains populated documents, convert them
      // all to ObjectIds re: #8443
      if (Array.isArray(val) && this.$__.populated[path]) {
        for (let i = 0; i < val.length; ++i) {
          if (val[i] instanceof Document) {
<<<<<<< HEAD
            val[i] = val[i]._id;
=======
            val.set(i, val[i]._doc._id, true);
>>>>>>> origin/wsj
          }
        }
      }
      delete this.$__.populated[path];
    }

<<<<<<< HEAD
    if (schema.$isSingleNested && val != null) {
=======
    if (val != null && schema.$isSingleNested) {
>>>>>>> origin/wsj
      _checkImmutableSubpaths(val, schema, priorVal);
    }

    this.$markValid(path);
  } catch (e) {
    if (e instanceof MongooseError.StrictModeError && e.isImmutableError) {
      this.invalidate(path, e);
    } else if (e instanceof MongooseError.CastError) {
      this.invalidate(e.path, e);
      if (e.$originalErrorPath) {
        this.invalidate(path,
          new MongooseError.CastError(schema.instance, val, path, e.$originalErrorPath));
      }
    } else {
      this.invalidate(path,
        new MongooseError.CastError(schema.instance, val, path, e));
    }
    shouldSet = false;
  }

  if (shouldSet) {
<<<<<<< HEAD
    this.$__set(pathToMark, path, constructing, parts, schema, val, priorVal);

    if (this.$__.savedState != null) {
      if (!this.isNew && !this.$__.savedState.hasOwnProperty(path)) {
        this.$__.savedState[path] = priorVal;
      } else if (this.$__.savedState.hasOwnProperty(path) && utils.deepEqual(val, this.$__.savedState[path])) {
        this.unmarkModified(path);
      }
=======
    let savedState = null;
    let savedStatePath = null;
    if (!constructing) {
      const doc = this.$isSubdocument ? this.ownerDocument() : this;
      savedState = doc.$__.savedState;
      savedStatePath = this.$isSubdocument ? this.$__.fullPath + '.' + path : path;
      doc.$__saveInitialState(savedStatePath);
    }

    this.$__set(pathToMark, path, options, constructing, parts, schema, val, priorVal);

    const isInTransaction = !!this.$__.session?.transaction;
    const isModifiedWithinTransaction = this.$__.session &&
      this.$__.session[sessionNewDocuments] &&
      this.$__.session[sessionNewDocuments].has(this) &&
      this.$__.session[sessionNewDocuments].get(this).modifiedPaths &&
      !this.$__.session[sessionNewDocuments].get(this).modifiedPaths.has(savedStatePath);
    if (savedState != null &&
        savedState.hasOwnProperty(savedStatePath) &&
        (!isInTransaction || isModifiedWithinTransaction) &&
        utils.deepEqual(val, savedState[savedStatePath])) {
      this.unmarkModified(path);
>>>>>>> origin/wsj
    }
  }

  if (schema.$isSingleNested && (this.isDirectModified(path) || val == null)) {
    cleanModifiedSubpaths(this, path);
  }

  return this;
};

/*!
 * ignore
 */

function _isManuallyPopulatedArray(val, ref) {
  if (!Array.isArray(val)) {
    return false;
  }
  if (val.length === 0) {
    return false;
  }

  for (const el of val) {
    if (!(el instanceof Document)) {
      return false;
    }
    const modelName = el.constructor.modelName;
    if (modelName == null) {
      return false;
    }
    if (el.constructor.modelName != ref && el.constructor.baseModelName != ref) {
      return false;
    }
  }

  return true;
}

/**
 * Sets the value of a path, or many paths.
<<<<<<< HEAD
 *
 * ####Example:
=======
 * Alias for [`.$set`](https://mongoosejs.com/docs/api/document.html#Document.prototype.$set()).
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     // path, value
 *     doc.set(path, value)
 *
 *     // object
 *     doc.set({
 *         path  : value
 *       , path2 : {
 *            path  : value
 *         }
 *     })
 *
 *     // on-the-fly cast to number
 *     doc.set(path, value, Number)
 *
 *     // on-the-fly cast to string
 *     doc.set(path, value, String)
 *
 *     // changing strict mode behavior
 *     doc.set(path, value, { strict: false });
 *
 * @param {String|Object} path path or object of key/vals to set
 * @param {Any} val the value to set
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for "on-the-fly" attributes
 * @param {Object} [options] optionally specify options that modify the behavior of the set
<<<<<<< HEAD
=======
 * @return {Document} this
>>>>>>> origin/wsj
 * @api public
 * @method set
 * @memberOf Document
 * @instance
 */

Document.prototype.set = Document.prototype.$set;

/**
 * Determine if we should mark this change as modified.
 *
<<<<<<< HEAD
=======
 * @param {never} pathToMark UNUSED
 * @param {String|Symbol} path
 * @param {Object} options
 * @param {Any} constructing
 * @param {never} parts UNUSED
 * @param {Schema} schema
 * @param {Any} val
 * @param {Any} priorVal
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api private
 * @method $__shouldModify
 * @memberOf Document
 * @instance
 */

<<<<<<< HEAD
Document.prototype.$__shouldModify = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  if (this.isNew) {
    return true;
  }

  // Re: the note about gh-7196, `val` is the raw value without casting or
  // setters if the full path is under a single nested subdoc because we don't
  // want to double run setters. So don't set it as modified. See gh-7264.
  if (this.$__schema.singleNestedPaths[path] != null) {
    return false;
=======
Document.prototype.$__shouldModify = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
  if (options && options._skipMarkModified) {
    return false;
  }
  if (this.$isNew) {
    return true;
  }
  // Is path already modified? If so, always modify. We may unmark modified later.
  if (path in this.$__.activePaths.getStatePaths('modify')) {
    return true;
>>>>>>> origin/wsj
  }

  if (val === void 0 && !this.$__isSelected(path)) {
    // when a path is not selected in a query, its initial
    // value will be undefined.
    return true;
  }

<<<<<<< HEAD
  if (val === void 0 && path in this.$__.activePaths.states.default) {
=======
  if (val === void 0 && path in this.$__.activePaths.getStatePaths('default')) {
>>>>>>> origin/wsj
    // we're just unsetting the default value which was never saved
    return false;
  }

  // gh-3992: if setting a populated field to a doc, don't mark modified
  // if they have the same _id
<<<<<<< HEAD
  if (this.populated(path) &&
      val instanceof Document &&
      deepEqual(val._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal || utils.getValue(path, this))) {
=======
  if (this.$populated(path) &&
      val instanceof Document &&
      deepEqual(val._doc._id, priorVal)) {
    return false;
  }

  if (!deepEqual(val, priorVal !== undefined ? priorVal : utils.getValue(path, this))) {
>>>>>>> origin/wsj
    return true;
  }

  if (!constructing &&
      val !== null &&
      val !== undefined &&
<<<<<<< HEAD
      path in this.$__.activePaths.states.default &&
=======
      path in this.$__.activePaths.getStatePaths('default') &&
>>>>>>> origin/wsj
      deepEqual(val, schema.getDefault(this, constructing))) {
    // a path with a default was $unset on the server
    // and the user is setting it to the same value again
    return true;
  }
  return false;
};

/**
 * Handles the actual setting of the value and marking the path modified if appropriate.
 *
<<<<<<< HEAD
=======
 * @param {String} pathToMark
 * @param {String|Symbol} path
 * @param {Object} options
 * @param {Any} constructing
 * @param {Array} parts
 * @param {Schema} schema
 * @param {Any} val
 * @param {Any} priorVal
>>>>>>> origin/wsj
 * @api private
 * @method $__set
 * @memberOf Document
 * @instance
 */

<<<<<<< HEAD
Document.prototype.$__set = function(pathToMark, path, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/embedded');

  const shouldModify = this.$__shouldModify(pathToMark, path, constructing, parts,
    schema, val, priorVal);
  const _this = this;

  if (shouldModify) {
=======
Document.prototype.$__set = function(pathToMark, path, options, constructing, parts, schema, val, priorVal) {
  Embedded = Embedded || require('./types/arraySubdocument');

  const shouldModify = this.$__shouldModify(pathToMark, path, options, constructing, parts,
    schema, val, priorVal);

  if (shouldModify) {
    if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[path]) {
      delete this.$__.primitiveAtomics[path];
      if (Object.keys(this.$__.primitiveAtomics).length === 0) {
        delete this.$__.primitiveAtomics;
      }
    }
>>>>>>> origin/wsj
    this.markModified(pathToMark);

    // handle directly setting arrays (gh-1126)
    MongooseArray || (MongooseArray = require('./types/array'));
<<<<<<< HEAD
    if (val && val.isMongooseArray) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (val.isMongooseDocumentArray) {
=======
    if (val && utils.isMongooseArray(val)) {
      val._registerAtomic('$set', val);

      // Update embedded document parent references (gh-5189)
      if (utils.isMongooseDocumentArray(val)) {
>>>>>>> origin/wsj
        val.forEach(function(item) {
          item && item.__parentArray && (item.__parentArray = val);
        });
      }
<<<<<<< HEAD

      // Small hack for gh-1638: if we're overwriting the entire array, ignore
      // paths that were modified before the array overwrite
      this.$__.activePaths.forEach(function(modifiedPath) {
        if (modifiedPath.startsWith(path + '.')) {
          _this.$__.activePaths.ignore(modifiedPath);
=======
    }
  } else if (Array.isArray(val) && Array.isArray(priorVal) && utils.isMongooseArray(val) && utils.isMongooseArray(priorVal)) {
    val[arrayAtomicsSymbol] = priorVal[arrayAtomicsSymbol];
    val[arrayAtomicsBackupSymbol] = priorVal[arrayAtomicsBackupSymbol];
    if (utils.isMongooseDocumentArray(val)) {
      val.forEach(doc => {
        if (doc != null) {
          doc.$isNew = false;
>>>>>>> origin/wsj
        }
      });
    }
  }

  let obj = this._doc;
  let i = 0;
  const l = parts.length;
  let cur = '';

  for (; i < l; i++) {
    const next = i + 1;
    const last = next === l;
    cur += (cur ? '.' + parts[i] : parts[i]);
    if (specialProperties.has(parts[i])) {
      return;
    }

    if (last) {
      if (obj instanceof Map) {
        obj.set(parts[i], val);
<<<<<<< HEAD
=======
      } else if (obj.$isSingleNested) {
        if (!(parts[i] in obj)) {
          obj[parts[i]] = val;
          obj._doc[parts[i]] = val;
        } else {
          obj._doc[parts[i]] = val;
        }
        if (shouldModify) {
          obj.markModified(parts[i]);
        }
>>>>>>> origin/wsj
      } else {
        obj[parts[i]] = val;
      }
    } else {
<<<<<<< HEAD
      if (utils.isPOJO(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]] instanceof Embedded) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && obj[parts[i]].$isSingleNested) {
        obj = obj[parts[i]];
      } else if (obj[parts[i]] && Array.isArray(obj[parts[i]])) {
        obj = obj[parts[i]];
      } else {
        obj[parts[i]] = obj[parts[i]] || {};
        obj = obj[parts[i]];
=======
      const isMap = obj instanceof Map;
      let value = isMap ? obj.get(parts[i]) : obj[parts[i]];
      if (utils.isPOJO(value)) {
        obj = value;
      } else if (value && value instanceof Embedded) {
        obj = value;
      } else if (value && !Array.isArray(value) && value.$isSingleNested) {
        obj = value;
      } else if (value && Array.isArray(value)) {
        obj = value;
      } else if (value == null) {
        value = {};
        if (isMap) {
          obj.set(parts[i], value);
        } else {
          obj[parts[i]] = value;
        }
        obj = value;
      } else {
        obj = value;
>>>>>>> origin/wsj
      }
    }
  }
};

/**
 * Gets a raw value from a path (no getters)
 *
 * @param {String} path
<<<<<<< HEAD
=======
 * @return {Any} Returns the value from the given `path`.
>>>>>>> origin/wsj
 * @api private
 */

Document.prototype.$__getValue = function(path) {
<<<<<<< HEAD
=======
  if (typeof path !== 'string' && !Array.isArray(path)) {
    throw new TypeError(
      `Invalid \`path\`. Must be either string or array. Got "${path}" (type ${typeof path})`
    );
  }
>>>>>>> origin/wsj
  return utils.getValue(path, this._doc);
};

/**
<<<<<<< HEAD
=======
 * Increments the numeric value at `path` by the given `val`.
 * When you call `save()` on this document, Mongoose will send a
 * [`$inc`](https://www.mongodb.com/docs/manual/reference/operator/update/inc/)
 * as opposed to a `$set`.
 *
 * #### Example:
 *
 *     const schema = new Schema({ counter: Number });
 *     const Test = db.model('Test', schema);
 *
 *     const doc = await Test.create({ counter: 0 });
 *     doc.$inc('counter', 2);
 *     await doc.save(); // Sends a `{ $inc: { counter: 2 } }` to MongoDB
 *     doc.counter; // 2
 *
 *     doc.counter += 2;
 *     await doc.save(); // Sends a `{ $set: { counter: 2 } }` to MongoDB
 *
 * @param {String|Array} path path or paths to update
 * @param {Number} val increment `path` by this value
 * @return {Document} this
 */

Document.prototype.$inc = function $inc(path, val) {
  if (val == null) {
    val = 1;
  }

  if (Array.isArray(path)) {
    path.forEach((p) => this.$inc(p, val));
    return this;
  }

  const schemaType = this.$__path(path);
  if (schemaType == null) {
    if (this.$__.strictMode === 'throw') {
      throw new StrictModeError(path);
    } else if (this.$__.strictMode === true) {
      return this;
    }
  } else if (schemaType.instance !== 'Number') {
    this.invalidate(path, new MongooseError.CastError(schemaType.instance, val, path));
    return this;
  }

  const currentValue = this.$__getValue(path) || 0;
  let shouldSet = false;
  let valToSet = null;
  let valToInc = val;

  try {
    val = schemaType.cast(val);
    valToSet = schemaType.applySetters(currentValue + val, this);
    valToInc = valToSet - currentValue;
    shouldSet = true;
  } catch (err) {
    this.invalidate(path, new MongooseError.CastError('number', val, path, err));
  }

  if (shouldSet) {
    this.$__.primitiveAtomics = this.$__.primitiveAtomics || {};
    if (this.$__.primitiveAtomics[path] == null) {
      this.$__.primitiveAtomics[path] = { $inc: valToInc };
    } else {
      this.$__.primitiveAtomics[path].$inc += valToInc;
    }
    this.markModified(path);
    this.$__setValue(path, valToSet);
  }

  return this;
};

/**
>>>>>>> origin/wsj
 * Sets a raw value for a path (no casting, setters, transformations)
 *
 * @param {String} path
 * @param {Object} value
<<<<<<< HEAD
=======
 * @return {Document} this
>>>>>>> origin/wsj
 * @api private
 */

Document.prototype.$__setValue = function(path, val) {
  utils.setValue(path, val, this._doc);
  return this;
};

/**
 * Returns the value of a path.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     // path
 *     doc.get('age') // 47
 *
 *     // dynamic casting to a string
 *     doc.get('age', String) // "47"
 *
 * @param {String} path
 * @param {Schema|String|Number|Buffer|*} [type] optionally specify a type for on-the-fly attributes
 * @param {Object} [options]
 * @param {Boolean} [options.virtuals=false] Apply virtuals before getting this path
 * @param {Boolean} [options.getters=true] If false, skip applying getters and just get the raw value
<<<<<<< HEAD
=======
 * @return {Any}
>>>>>>> origin/wsj
 * @api public
 */

Document.prototype.get = function(path, type, options) {
  let adhoc;
<<<<<<< HEAD
  options = options || {};
  if (type) {
    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
  }

  let schema = this.$__path(path);
  if (schema == null) {
    schema = this.$__schema.virtualpath(path);
  }
  if (schema instanceof MixedSchema) {
=======
  if (options == null) {
    options = {};
  }
  if (type) {
    adhoc = this.$__schema.interpretAsType(path, type, this.$__schema.options);
  }
  const noDottedPath = options.noDottedPath;

  // Fast path if we know we're just accessing top-level path on the document:
  // just get the schema path, avoid `$__path()` because that does string manipulation
  let schema = noDottedPath ? this.$__schema.paths[path] : this.$__path(path);
  if (schema == null) {
    schema = this.$__schema.virtualpath(path);

    if (schema != null) {
      return schema.applyGetters(void 0, this);
    }
  }

  if (noDottedPath) {
    let obj = this._doc[path];
    if (adhoc) {
      obj = adhoc.cast(obj);
    }
    if (schema != null && options.getters !== false) {
      return schema.applyGetters(obj, this);
    }
    return obj;
  }

  if (schema != null && schema.instance === 'Mixed') {
>>>>>>> origin/wsj
    const virtual = this.$__schema.virtualpath(path);
    if (virtual != null) {
      schema = virtual;
    }
  }
<<<<<<< HEAD
  const pieces = path.indexOf('.') === -1 ? [path] : path.split('.');
  let obj = this._doc;

  if (schema instanceof VirtualType) {
    return schema.applyGetters(void 0, this);
  }

  // Might need to change path for top-level alias
  if (typeof this.$__schema.aliases[pieces[0]] == 'string') {
=======

  const hasDot = path.indexOf('.') !== -1;
  let obj = this._doc;

  const pieces = hasDot ? path.split('.') : [path];
  // Might need to change path for top-level alias
  if (typeof this.$__schema.aliases[pieces[0]] === 'string') {
>>>>>>> origin/wsj
    pieces[0] = this.$__schema.aliases[pieces[0]];
  }

  for (let i = 0, l = pieces.length; i < l; i++) {
    if (obj && obj._doc) {
      obj = obj._doc;
    }

    if (obj == null) {
      obj = void 0;
    } else if (obj instanceof Map) {
      obj = obj.get(pieces[i], { getters: false });
    } else if (i === l - 1) {
      obj = utils.getValue(pieces[i], obj);
    } else {
      obj = obj[pieces[i]];
    }
  }

  if (adhoc) {
    obj = adhoc.cast(obj);
  }

  if (schema != null && options.getters !== false) {
    obj = schema.applyGetters(obj, this);
  } else if (this.$__schema.nested[path] && options.virtuals) {
    // Might need to apply virtuals if this is a nested path
<<<<<<< HEAD
    return applyVirtuals(this, utils.clone(obj) || {}, { path: path });
=======
    return applyVirtuals(this, clone(obj) || {}, { path: path });
>>>>>>> origin/wsj
  }

  return obj;
};

/*!
 * ignore
 */

Document.prototype[getSymbol] = Document.prototype.get;
<<<<<<< HEAD
=======
Document.prototype.$get = Document.prototype.get;
>>>>>>> origin/wsj

/**
 * Returns the schematype for the given `path`.
 *
 * @param {String} path
<<<<<<< HEAD
=======
 * @return {SchemaPath}
>>>>>>> origin/wsj
 * @api private
 * @method $__path
 * @memberOf Document
 * @instance
 */

Document.prototype.$__path = function(path) {
  const adhocs = this.$__.adhocPaths;
  const adhocType = adhocs && adhocs.hasOwnProperty(path) ? adhocs[path] : null;

  if (adhocType) {
    return adhocType;
  }
  return this.$__schema.path(path);
};

/**
 * Marks the path as having pending changes to write to the db.
 *
<<<<<<< HEAD
 * _Very helpful when using [Mixed](./schematypes.html#mixed) types._
 *
 * ####Example:
=======
 * _Very helpful when using [Mixed](https://mongoosejs.com/docs/schematypes.html#mixed) types._
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     doc.mixed.type = 'changed';
 *     doc.markModified('mixed.type');
 *     doc.save() // changes to mixed.type are now persisted
 *
 * @param {String} path the path to mark modified
 * @param {Document} [scope] the scope to run validators with
 * @api public
 */

Document.prototype.markModified = function(path, scope) {
<<<<<<< HEAD
  this.$__.activePaths.modify(path);
  if (scope != null && !this.ownerDocument) {
=======
  this.$__saveInitialState(path);

  this.$__.activePaths.modify(path);
  if (scope != null && !this.$isSubdocument) {
    this.$__.pathsToScopes = this.$__pathsToScopes || {};
>>>>>>> origin/wsj
    this.$__.pathsToScopes[path] = scope;
  }
};

<<<<<<< HEAD
/**
 * Clears the modified state on the specified path.
 *
 * ####Example:
=======
/*!
 * ignore
 */

Document.prototype.$__saveInitialState = function $__saveInitialState(path) {
  const savedState = this.$__.savedState;
  const savedStatePath = path;
  if (savedState != null) {
    const firstDot = savedStatePath.indexOf('.');
    const topLevelPath = firstDot === -1 ? savedStatePath : savedStatePath.slice(0, firstDot);
    if (!savedState.hasOwnProperty(topLevelPath)) {
      savedState[topLevelPath] = clone(this.$__getValue(topLevelPath));
    }
  }
};

/**
 * Clears the modified state on the specified path.
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     doc.foo = 'bar';
 *     doc.unmarkModified('foo');
 *     doc.save(); // changes to foo will not be persisted
 *
 * @param {String} path the path to unmark modified
 * @api public
 */

Document.prototype.unmarkModified = function(path) {
  this.$__.activePaths.init(path);
<<<<<<< HEAD
  delete this.$__.pathsToScopes[path];
=======
  if (this.$__.pathsToScopes != null) {
    delete this.$__.pathsToScopes[path];
  }
>>>>>>> origin/wsj
};

/**
 * Don't run validation on this path or persist changes to this path.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     doc.foo = null;
 *     doc.$ignore('foo');
 *     doc.save(); // changes to foo will not be persisted and validators won't be run
 *
 * @memberOf Document
 * @instance
 * @method $ignore
 * @param {String} path the path to ignore
 * @api public
 */

Document.prototype.$ignore = function(path) {
  this.$__.activePaths.ignore(path);
};

/**
 * Returns the list of paths that have been directly modified. A direct
 * modified path is a path that you explicitly set, whether via `doc.foo = 'bar'`,
 * `Object.assign(doc, { foo: 'bar' })`, or `doc.set('foo', 'bar')`.
 *
 * A path `a` may be in `modifiedPaths()` but not in `directModifiedPaths()`
 * because a child of `a` was directly modified.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
 *
>>>>>>> origin/wsj
 *     const schema = new Schema({ foo: String, nested: { bar: String } });
 *     const Model = mongoose.model('Test', schema);
 *     await Model.create({ foo: 'original', nested: { bar: 'original' } });
 *
 *     const doc = await Model.findOne();
 *     doc.nested.bar = 'modified';
 *     doc.directModifiedPaths(); // ['nested.bar']
 *     doc.modifiedPaths(); // ['nested', 'nested.bar']
 *
<<<<<<< HEAD
 * @return {Array}
=======
 * @return {String[]}
>>>>>>> origin/wsj
 * @api public
 */

Document.prototype.directModifiedPaths = function() {
<<<<<<< HEAD
  return Object.keys(this.$__.activePaths.states.modify);
=======
  return Object.keys(this.$__.activePaths.getStatePaths('modify'));
>>>>>>> origin/wsj
};

/**
 * Returns true if the given path is nullish or only contains empty objects.
 * Useful for determining whether this subdoc will get stripped out by the
<<<<<<< HEAD
 * [minimize option](/docs/guide.html#minimize).
 *
 * ####Example:
=======
 * [minimize option](https://mongoosejs.com/docs/guide.html#minimize).
 *
 * #### Example:
 *
>>>>>>> origin/wsj
 *     const schema = new Schema({ nested: { foo: String } });
 *     const Model = mongoose.model('Test', schema);
 *     const doc = new Model({});
 *     doc.$isEmpty('nested'); // true
 *     doc.nested.$isEmpty(); // true
 *
 *     doc.nested.foo = 'bar';
 *     doc.$isEmpty('nested'); // false
 *     doc.nested.$isEmpty(); // false
 *
<<<<<<< HEAD
=======
 * @param {String} [path]
>>>>>>> origin/wsj
 * @memberOf Document
 * @instance
 * @api public
 * @method $isEmpty
 * @return {Boolean}
 */

Document.prototype.$isEmpty = function(path) {
  const isEmptyOptions = {
    minimize: true,
    virtuals: false,
    getters: false,
    transform: false
  };

<<<<<<< HEAD
  if (arguments.length > 0) {
    const v = this.get(path);
=======
  if (arguments.length !== 0) {
    const v = this.$get(path);
>>>>>>> origin/wsj
    if (v == null) {
      return true;
    }
    if (typeof v !== 'object') {
      return false;
    }
    if (utils.isPOJO(v)) {
      return _isEmpty(v);
    }
    return Object.keys(v.toObject(isEmptyOptions)).length === 0;
  }

  return Object.keys(this.toObject(isEmptyOptions)).length === 0;
};

<<<<<<< HEAD
=======
/*!
 * ignore
 */

>>>>>>> origin/wsj
function _isEmpty(v) {
  if (v == null) {
    return true;
  }
  if (typeof v !== 'object' || Array.isArray(v)) {
    return false;
  }
  for (const key of Object.keys(v)) {
    if (!_isEmpty(v[key])) {
      return false;
    }
  }
  return true;
}

/**
 * Returns the list of paths that have been modified.
 *
 * @param {Object} [options]
 * @param {Boolean} [options.includeChildren=false] if true, returns children of modified paths as well. For example, if false, the list of modified paths for `doc.colors = { primary: 'blue' };` will **not** contain `colors.primary`. If true, `modifiedPaths()` will return an array that contains `colors.primary`.
<<<<<<< HEAD
 * @return {Array}
=======
 * @return {String[]}
>>>>>>> origin/wsj
 * @api public
 */

Document.prototype.modifiedPaths = function(options) {
  options = options || {};
<<<<<<< HEAD
  const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
  const _this = this;
  return directModifiedPaths.reduce(function(list, path) {
    const parts = path.split('.');
    list = list.concat(parts.reduce(function(chains, part, i) {
      return chains.concat(parts.slice(0, i).concat(part).join('.'));
    }, []).filter(function(chain) {
      return (list.indexOf(chain) === -1);
    }));

    if (!options.includeChildren) {
      return list;
    }

    let cur = _this.get(path);
    if (cur != null && typeof cur === 'object') {
      if (cur._doc) {
        cur = cur._doc;
      }
      if (Array.isArray(cur)) {
        const len = cur.length;
        for (let i = 0; i < len; ++i) {
          if (list.indexOf(path + '.' + i) === -1) {
            list.push(path + '.' + i);
            if (cur[i] != null && cur[i].$__) {
              const modified = cur[i].modifiedPaths();
              for (const childPath of modified) {
                list.push(path + '.' + i + '.' + childPath);
=======

  const directModifiedPaths = Object.keys(this.$__.activePaths.getStatePaths('modify'));
  const result = new Set();

  let i = 0;
  let j = 0;
  const len = directModifiedPaths.length;

  for (i = 0; i < len; ++i) {
    const path = directModifiedPaths[i];
    const parts = parentPaths(path);
    const pLen = parts.length;

    for (j = 0; j < pLen; ++j) {
      result.add(parts[j]);
    }

    if (!options.includeChildren) {
      continue;
    }

    let ii = 0;
    let cur = this.$get(path);
    if (typeof cur === 'object' && cur !== null) {
      if (cur._doc) {
        cur = cur._doc;
      }
      const len = cur.length;
      if (Array.isArray(cur)) {
        for (ii = 0; ii < len; ++ii) {
          const subPath = path + '.' + ii;
          if (!result.has(subPath)) {
            result.add(subPath);
            if (cur[ii] != null && cur[ii].$__) {
              const modified = cur[ii].modifiedPaths();
              let iii = 0;
              const iiiLen = modified.length;
              for (iii = 0; iii < iiiLen; ++iii) {
                result.add(subPath + '.' + modified[iii]);
>>>>>>> origin/wsj
              }
            }
          }
        }
      } else {
<<<<<<< HEAD
        Object.keys(cur).
          filter(function(key) {
            return list.indexOf(path + '.' + key) === -1;
          }).
          forEach(function(key) {
            list.push(path + '.' + key);
          });
      }
    }

    return list;
  }, []);
=======
        const keys = Object.keys(cur);
        let ii = 0;
        const len = keys.length;
        for (ii = 0; ii < len; ++ii) {
          result.add(path + '.' + keys[ii]);
        }
      }
    }
  }
  return Array.from(result);
>>>>>>> origin/wsj
};

Document.prototype[documentModifiedPaths] = Document.prototype.modifiedPaths;

/**
 * Returns true if any of the given paths is modified, else false. If no arguments, returns `true` if any path
 * in this document is modified.
 *
 * If `path` is given, checks if a path or any full path containing `path` as part of its path chain has been modified.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isModified()                      // true
 *     doc.isModified('documents')           // true
 *     doc.isModified('documents.0.title')   // true
 *     doc.isModified('documents otherProp') // true
 *     doc.isDirectModified('documents')     // false
 *
 * @param {String} [path] optional
<<<<<<< HEAD
=======
 * @param {Object} [options]
 * @param {Boolean} [options.ignoreAtomics=false] If true, doesn't return true if path is underneath an array that was modified with atomic operations like `push()`
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api public
 */

<<<<<<< HEAD
Document.prototype.isModified = function(paths, modifiedPaths) {
  if (paths) {
    if (!Array.isArray(paths)) {
      paths = paths.split(' ');
    }
    const modified = modifiedPaths || this[documentModifiedPaths]();
    const directModifiedPaths = Object.keys(this.$__.activePaths.states.modify);
=======
Document.prototype.isModified = function(paths, options, modifiedPaths) {
  if (paths) {
    const ignoreAtomics = options && options.ignoreAtomics;
    const directModifiedPathsObj = this.$__.activePaths.states.modify;
    if (directModifiedPathsObj == null) {
      return false;
    }

    if (typeof paths === 'string') {
      paths = paths.indexOf(' ') === -1 ? [paths] : paths.split(' ');
    }

    for (const path of paths) {
      if (directModifiedPathsObj[path] != null) {
        return true;
      }
    }

    const modified = modifiedPaths || this[documentModifiedPaths]();
>>>>>>> origin/wsj
    const isModifiedChild = paths.some(function(path) {
      return !!~modified.indexOf(path);
    });

<<<<<<< HEAD
=======
    let directModifiedPaths = Object.keys(directModifiedPathsObj);
    if (ignoreAtomics) {
      directModifiedPaths = directModifiedPaths.filter(path => {
        const value = this.$__getValue(path);
        if (value != null && value[arrayAtomicsSymbol] != null && value[arrayAtomicsSymbol].$set === undefined) {
          return false;
        }
        return true;
      });
    }
>>>>>>> origin/wsj
    return isModifiedChild || paths.some(function(path) {
      return directModifiedPaths.some(function(mod) {
        return mod === path || path.startsWith(mod + '.');
      });
    });
  }

  return this.$__.activePaths.some('modify');
};

<<<<<<< HEAD
=======
/**
 * Alias of [`.isModified`](https://mongoosejs.com/docs/api/document.html#Document.prototype.isModified())
 *
 * @method $isModified
 * @memberOf Document
 * @api public
 */

Document.prototype.$isModified = Document.prototype.isModified;

>>>>>>> origin/wsj
Document.prototype[documentIsModified] = Document.prototype.isModified;

/**
 * Checks if a path is set to its default.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     MyModel = mongoose.model('test', { name: { type: String, default: 'Val '} });
 *     const m = new MyModel();
 *     m.$isDefault('name'); // true
 *
 * @memberOf Document
 * @instance
 * @method $isDefault
 * @param {String} [path]
 * @return {Boolean}
 * @api public
 */

Document.prototype.$isDefault = function(path) {
  if (path == null) {
    return this.$__.activePaths.some('default');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
<<<<<<< HEAD
    return this.$__.activePaths.states.default.hasOwnProperty(path);
=======
    return this.$__.activePaths.getStatePaths('default').hasOwnProperty(path);
>>>>>>> origin/wsj
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

<<<<<<< HEAD
  return paths.some(path => this.$__.activePaths.states.default.hasOwnProperty(path));
};

/**
 * Getter/setter, determines whether the document was removed or not.
 *
 * ####Example:
 *     product.remove(function (err, product) {
 *       product.$isDeleted(); // true
 *       product.remove(); // no-op, doesn't send anything to the db
 *
 *       product.$isDeleted(false);
 *       product.$isDeleted(); // false
 *       product.remove(); // will execute a remove against the db
 *     })
 *
 * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted
 * @return {Boolean} whether mongoose thinks this doc is deleted.
=======
  return paths.some(path => this.$__.activePaths.getStatePaths('default').hasOwnProperty(path));
};

/**
 * Getter/setter, determines whether the document was deleted. The `Model.prototype.deleteOne()` method sets `$isDeleted` if the delete operation succeeded.
 *
 * #### Example:
 *
 *     const product = await product.deleteOne();
 *     product.$isDeleted(); // true
 *     product.deleteOne(); // no-op, doesn't send anything to the db
 *
 *     product.$isDeleted(false);
 *     product.$isDeleted(); // false
 *     product.deleteOne(); // will execute a remove against the db
 *
 *
 * @param {Boolean} [val] optional, overrides whether mongoose thinks the doc is deleted
 * @return {Boolean|Document} whether mongoose thinks this doc is deleted.
>>>>>>> origin/wsj
 * @method $isDeleted
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.$isDeleted = function(val) {
  if (arguments.length === 0) {
    return !!this.$__.isDeleted;
  }

  this.$__.isDeleted = !!val;
  return this;
};

/**
 * Returns true if `path` was directly set and modified, else false.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     doc.set('documents.0.title', 'changed');
 *     doc.isDirectModified('documents.0.title') // true
 *     doc.isDirectModified('documents') // false
 *
<<<<<<< HEAD
 * @param {String|Array<String>} path
=======
 * @param {String|String[]} [path]
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api public
 */

Document.prototype.isDirectModified = function(path) {
  if (path == null) {
    return this.$__.activePaths.some('modify');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
<<<<<<< HEAD
    return this.$__.activePaths.states.modify.hasOwnProperty(path);
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

  return paths.some(path => this.$__.activePaths.states.modify.hasOwnProperty(path));
=======
    const res = this.$__.activePaths.getStatePaths('modify').hasOwnProperty(path);
    if (res || path.indexOf('.') === -1) {
      return res;
    }

    const pieces = path.split('.');
    for (let i = 0; i < pieces.length - 1; ++i) {
      const subpath = pieces.slice(0, i + 1).join('.');
      const subdoc = this.$get(subpath);
      if (subdoc != null && subdoc.$__ != null && subdoc.isDirectModified(pieces.slice(i + 1).join('.'))) {
        return true;
      }
    }

    return false;
  }

  let paths = path;
  if (typeof paths === 'string') {
    paths = paths.split(' ');
  }

  return paths.some(path => this.isDirectModified(path));
>>>>>>> origin/wsj
};

/**
 * Checks if `path` is in the `init` state, that is, it was set by `Document#init()` and not modified since.
 *
<<<<<<< HEAD
 * @param {String} path
=======
 * @param {String} [path]
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api public
 */

Document.prototype.isInit = function(path) {
  if (path == null) {
    return this.$__.activePaths.some('init');
  }

  if (typeof path === 'string' && path.indexOf(' ') === -1) {
<<<<<<< HEAD
    return this.$__.activePaths.states.init.hasOwnProperty(path);
=======
    return this.$__.activePaths.getStatePaths('init').hasOwnProperty(path);
>>>>>>> origin/wsj
  }

  let paths = path;
  if (!Array.isArray(paths)) {
    paths = paths.split(' ');
  }

<<<<<<< HEAD
  return paths.some(path => this.$__.activePaths.states.init.hasOwnProperty(path));
=======
  return paths.some(path => this.$__.activePaths.getStatePaths('init').hasOwnProperty(path));
>>>>>>> origin/wsj
};

/**
 * Checks if `path` was selected in the source query which initialized this document.
 *
<<<<<<< HEAD
 * ####Example
 *
 *     Thing.findOne().select('name').exec(function (err, doc) {
 *        doc.isSelected('name') // true
 *        doc.isSelected('age')  // false
 *     })
 *
 * @param {String|Array<String>} path
=======
 * #### Example:
 *
 *     const doc = await Thing.findOne().select('name');
 *     doc.isSelected('name') // true
 *     doc.isSelected('age')  // false
 *
 * @param {String|String[]} path
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api public
 */

Document.prototype.isSelected = function isSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }
<<<<<<< HEAD

=======
  if (!path) {
    return false;
  }
>>>>>>> origin/wsj
  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__isSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (path in this.$__.selected) {
    return inclusive;
  }

  const pathDot = path + '.';

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }

    if (cur.startsWith(pathDot)) {
      return inclusive || cur !== pathDot;
    }

    if (pathDot.startsWith(cur + '.')) {
      return inclusive;
    }
  }
<<<<<<< HEAD

=======
>>>>>>> origin/wsj
  return !inclusive;
};

Document.prototype.$__isSelected = Document.prototype.isSelected;

/**
 * Checks if `path` was explicitly selected. If no projection, always returns
 * true.
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     Thing.findOne().select('nested.name').exec(function (err, doc) {
 *        doc.isDirectSelected('nested.name') // true
 *        doc.isDirectSelected('nested.otherName') // false
 *        doc.isDirectSelected('nested')  // false
 *     })
 *
 * @param {String} path
 * @return {Boolean}
 * @api public
 */

Document.prototype.isDirectSelected = function isDirectSelected(path) {
  if (this.$__.selected == null) {
    return true;
  }

  if (path === '_id') {
    return this.$__.selected._id !== 0;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.isDirectSelected(p));
  }

  const paths = Object.keys(this.$__.selected);
  let inclusive = null;

  if (paths.length === 1 && paths[0] === '_id') {
    // only _id was selected.
    return this.$__.selected._id === 0;
  }

  for (const cur of paths) {
    if (cur === '_id') {
      continue;
    }
    if (!isDefiningProjection(this.$__.selected[cur])) {
      continue;
    }
    inclusive = !!this.$__.selected[cur];
    break;
  }

  if (inclusive === null) {
    return true;
  }

  if (this.$__.selected.hasOwnProperty(path)) {
    return inclusive;
  }

  return !inclusive;
};

/**
 * Executes registered validation rules for this document.
 *
<<<<<<< HEAD
 * ####Note:
 *
 * This method is called `pre` save and if a validation rule is violated, [save](#model_Model-save) is aborted and the error is returned to your `callback`.
 *
 * ####Example:
 *
 *     doc.validate(function (err) {
 *       if (err) handleError(err);
 *       else // validation passed
 *     });
=======
 * #### Note:
 *
 * This method is called `pre` save and if a validation rule is violated, [save](https://mongoosejs.com/docs/api/model.html#Model.prototype.save()) is aborted and the error is thrown.
 *
 * #### Example:
 *
 *     await doc.validate({ validateModifiedOnly: false, pathsToSkip: ['name', 'email']});
>>>>>>> origin/wsj
 *
 * @param {Array|String} [pathsToValidate] list of paths to validate. If set, Mongoose will validate only the modified paths that are in the given list.
 * @param {Object} [options] internal options
 * @param {Boolean} [options.validateModifiedOnly=false] if `true` mongoose validates only modified paths.
 * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.
<<<<<<< HEAD
 * @param {Function} [callback] optional callback called after validation completes, passing an error if one occurred
 * @return {Promise} Promise
 * @api public
 */

Document.prototype.validate = function(pathsToValidate, options, callback) {
  let parallelValidate;
  this.$op = 'validate';

  if (this.ownerDocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (arguments.length === 1) {
    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {
      options = arguments[0];
      callback = null;
      pathsToValidate = null;
    } else if (typeof arguments[0] === 'function') {
      callback = arguments[0];
      options = null;
      pathsToValidate = null;
    }
  } else if (typeof pathsToValidate === 'function') {
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = pathsToValidate;
    pathsToValidate = null;
=======
 * @return {Promise} Returns a Promise.
 * @api public
 */

Document.prototype.validate = async function validate(pathsToValidate, options) {
  if (typeof pathsToValidate === 'function' || typeof options === 'function' || typeof arguments[2] === 'function') {
    throw new MongooseError('Document.prototype.validate() no longer accepts a callback');
  }
  let parallelValidate;
  this.$op = 'validate';

  if (arguments.length === 1) {
    if (typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {
      options = arguments[0];
      pathsToValidate = null;
    }
>>>>>>> origin/wsj
  }
  if (options && typeof options.pathsToSkip === 'string') {
    const isOnePathOnly = options.pathsToSkip.indexOf(' ') === -1;
    options.pathsToSkip = isOnePathOnly ? [options.pathsToSkip] : options.pathsToSkip.split(' ');
  }
<<<<<<< HEAD

  return promiseOrCallback(callback, cb => {
    if (parallelValidate != null) {
      return cb(parallelValidate);
    }

    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      cb(error);
    });
  }, this.constructor.events);
};

=======
  const _skipParallelValidateCheck = options && options._skipParallelValidateCheck;

  if (this.$isSubdocument != null) {
    // Skip parallel validate check for subdocuments
  } else if (this.$__.validating && !_skipParallelValidateCheck) {
    parallelValidate = new ParallelValidateError(this, {
      parentStack: options && options.parentStack,
      conflictStack: this.$__.validating.stack
    });
  } else if (!_skipParallelValidateCheck) {
    this.$__.validating = new ParallelValidateError(this, { parentStack: options && options.parentStack });
  }

  if (parallelValidate != null) {
    throw parallelValidate;
  }

  return new Promise((resolve, reject) => {
    this.$__validate(pathsToValidate, options, (error) => {
      this.$op = null;
      this.$__.validating = null;
      if (error != null) {
        return reject(error);
      }
      resolve();
    });
  });
};

/**
 * Alias of [`.validate`](https://mongoosejs.com/docs/api/document.html#Document.prototype.validate())
 *
 * @method $validate
 * @memberOf Document
 * @api public
 */

Document.prototype.$validate = Document.prototype.validate;

>>>>>>> origin/wsj
/*!
 * ignore
 */

function _evaluateRequiredFunctions(doc) {
<<<<<<< HEAD
  Object.keys(doc.$__.activePaths.states.require).forEach(path => {
    const p = doc.$__schema.path(path);

    if (p != null && typeof p.originalRequiredValue === 'function') {
      doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
    }
  });
=======
  const requiredFields = Object.keys(doc.$__.activePaths.getStatePaths('require'));
  let i = 0;
  const len = requiredFields.length;
  for (i = 0; i < len; ++i) {
    const path = requiredFields[i];

    const p = doc.$__schema.path(path);

    if (p != null && typeof p.originalRequiredValue === 'function') {
      doc.$__.cachedRequired = doc.$__.cachedRequired || {};
      try {
        doc.$__.cachedRequired[path] = p.originalRequiredValue.call(doc, doc);
      } catch (err) {
        doc.invalidate(path, err);
      }
    }
  }
>>>>>>> origin/wsj
}

/*!
 * ignore
 */

<<<<<<< HEAD
function _getPathsToValidate(doc) {
  const skipSchemaValidators = {};

  _evaluateRequiredFunctions(doc);
  // only validate required fields when necessary
  let paths = new Set(Object.keys(doc.$__.activePaths.states.require).filter(function(path) {
    if (!doc.$__isSelected(path) && !doc.isModified(path)) {
      return false;
    }
    if (path in doc.$__.cachedRequired) {
=======
function _getPathsToValidate(doc, pathsToValidate, pathsToSkip, isNestedValidate) {
  const doValidateOptions = {};

  _evaluateRequiredFunctions(doc);
  // only validate required fields when necessary
  let paths = new Set(Object.keys(doc.$__.activePaths.getStatePaths('require')).filter(function(path) {
    if (!doc.$__isSelected(path) && !doc.$isModified(path)) {
      return false;
    }
    if (doc.$__.cachedRequired != null && path in doc.$__.cachedRequired) {
>>>>>>> origin/wsj
      return doc.$__.cachedRequired[path];
    }
    return true;
  }));

<<<<<<< HEAD

  Object.keys(doc.$__.activePaths.states.init).forEach(addToPaths);
  Object.keys(doc.$__.activePaths.states.modify).forEach(addToPaths);
  Object.keys(doc.$__.activePaths.states.default).forEach(addToPaths);
  function addToPaths(p) { paths.add(p); }

  const subdocs = doc.$getAllSubdocs();
  const modifiedPaths = doc.modifiedPaths();
  for (const subdoc of subdocs) {
    if (subdoc.$basePath) {
      // Remove child paths for now, because we'll be validating the whole
      // subdoc
      for (const p of paths) {
        if (p === null || p.startsWith(subdoc.$basePath + '.')) {
          paths.delete(p);
        }
      }

      if (doc.isModified(subdoc.$basePath, modifiedPaths) &&
            !doc.isDirectModified(subdoc.$basePath) &&
            !doc.$isDefault(subdoc.$basePath)) {
        paths.add(subdoc.$basePath);

        skipSchemaValidators[subdoc.$basePath] = true;
      }
    }
=======
  Object.keys(doc.$__.activePaths.getStatePaths('init')).forEach(addToPaths);
  Object.keys(doc.$__.activePaths.getStatePaths('modify')).forEach(addToPaths);
  Object.keys(doc.$__.activePaths.getStatePaths('default')).forEach(addToPaths);
  function addToPaths(p) { paths.add(p); }

  if (!isNestedValidate) {
    // If we're validating a subdocument, all this logic will run anyway on the top-level document, so skip for subdocuments
    const subdocs = doc.$getAllSubdocs({ useCache: true });
    const modifiedPaths = doc.modifiedPaths();
    for (const subdoc of subdocs) {
      if (subdoc.$basePath) {
        const fullPathToSubdoc = subdoc.$isSingleNested ? subdoc.$__pathRelativeToParent() : subdoc.$__fullPathWithIndexes();

        // Remove child paths for now, because we'll be validating the whole
        // subdoc.
        // The following is a faster take on looping through every path in `paths`
        // and checking if the path starts with `fullPathToSubdoc` re: gh-13191
        for (const modifiedPath of subdoc.modifiedPaths()) {
          paths.delete(fullPathToSubdoc + '.' + modifiedPath);
        }

        if (doc.$isModified(fullPathToSubdoc, null, modifiedPaths) &&
              // Avoid using isDirectModified() here because that does additional checks on whether the parent path
              // is direct modified, which can cause performance issues re: gh-14897
              !doc.$__.activePaths.getStatePaths('modify').hasOwnProperty(fullPathToSubdoc) &&
              !doc.$isDefault(fullPathToSubdoc)) {
          paths.add(fullPathToSubdoc);

          if (doc.$__.pathsToScopes == null) {
            doc.$__.pathsToScopes = {};
          }
          doc.$__.pathsToScopes[fullPathToSubdoc] = subdoc.$isDocumentArrayElement ?
            subdoc.__parentArray :
            subdoc.$parent();

          doValidateOptions[fullPathToSubdoc] = { skipSchemaValidators: true };
          if (subdoc.$isDocumentArrayElement && subdoc.__index != null) {
            doValidateOptions[fullPathToSubdoc].index = subdoc.__index;
          }
        }
      }
    }
  }

  for (const path of paths) {
    const _pathType = doc.$__schema.path(path);
    if (!_pathType) {
      continue;
    }

    if (_pathType.$isMongooseDocumentArray) {
      for (const p of paths) {
        if (p == null || p.startsWith(_pathType.path + '.')) {
          paths.delete(p);
        }
      }
    }

    // Optimization: if primitive path with no validators, or array of primitives
    // with no validators, skip validating this path entirely.
    if (!_pathType.caster && _pathType.validators.length === 0 && !_pathType.$parentSchemaDocArray) {
      paths.delete(path);
    } else if (_pathType.$isMongooseArray &&
      !_pathType.$isMongooseDocumentArray && // Skip document arrays...
      !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
      _pathType.validators.length === 0 && // and arrays with top-level validators
      _pathType.$embeddedSchemaType.validators.length === 0) {
      paths.delete(path);
    }
  }


  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  } else if (Array.isArray(pathsToSkip)) {
    paths = _handlePathsToSkip(paths, pathsToSkip);
>>>>>>> origin/wsj
  }

  // from here on we're not removing items from paths

  // gh-661: if a whole array is modified, make sure to run validation on all
  // the children as well
<<<<<<< HEAD
  for (const path of paths) {
    const _pathType = doc.$__schema.path(path);
    if (!_pathType ||
        !_pathType.$isMongooseArray ||
        // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        (_pathType.$isMongooseDocumentArray && !get(_pathType, 'schemaOptions.required'))) {
      continue;
    }

    const val = doc.$__getValue(path);
    _pushNestedArrayPaths(val, paths, path);
  }

  function _pushNestedArrayPaths(val, paths, path) {
    if (val != null) {
      const numElements = val.length;
      for (let j = 0; j < numElements; ++j) {
        if (Array.isArray(val[j])) {
          _pushNestedArrayPaths(val[j], paths, path + '.' + j);
        } else {
          paths.add(path + '.' + j);
        }
      }
    }
  }
=======
  _addArrayPathsToValidate(doc, paths);
>>>>>>> origin/wsj

  const flattenOptions = { skipArrays: true };
  for (const pathToCheck of paths) {
    if (doc.$__schema.nested[pathToCheck]) {
      let _v = doc.$__getValue(pathToCheck);
      if (isMongooseObject(_v)) {
        _v = _v.toObject({ transform: false });
      }
      const flat = flatten(_v, pathToCheck, flattenOptions, doc.$__schema);
<<<<<<< HEAD
      Object.keys(flat).forEach(addToPaths);
=======
      // Single nested paths (paths embedded under single nested subdocs) will
      // be validated on their own when we call `validate()` on the subdoc itself.
      // Re: gh-8468
      Object.keys(flat).filter(path => !doc.$__schema.singleNestedPaths.hasOwnProperty(path)).forEach(addToPaths);
>>>>>>> origin/wsj
    }
  }

  for (const path of paths) {
<<<<<<< HEAD
    // Single nested paths (paths embedded under single nested subdocs) will
    // be validated on their own when we call `validate()` on the subdoc itself.
    // Re: gh-8468
    if (doc.$__schema.singleNestedPaths.hasOwnProperty(path)) {
      paths.delete(path);
      continue;
    }
    const _pathType = doc.$__schema.path(path);
    if (!_pathType || !_pathType.$isSchemaMap) {
=======
    const _pathType = doc.$__schema.path(path);

    if (!_pathType) {
      continue;
    }

    // If underneath a document array, may need to re-validate the parent
    // array re: gh-6818. Do this _after_ adding subpaths, because
    // we don't want to add every array subpath.
    if (_pathType.$parentSchemaDocArray && typeof _pathType.$parentSchemaDocArray.path === 'string') {
      paths.add(_pathType.$parentSchemaDocArray.path);
    }

    if (!_pathType.$isSchemaMap) {
>>>>>>> origin/wsj
      continue;
    }

    const val = doc.$__getValue(path);
    if (val == null) {
      continue;
    }
    for (const key of val.keys()) {
      paths.add(path + '.' + key);
    }
  }

  paths = Array.from(paths);
<<<<<<< HEAD
  return [paths, skipSchemaValidators];
=======
  return [paths, doValidateOptions];
}

function _addArrayPathsToValidate(doc, paths) {
  for (const path of paths) {
    const _pathType = doc.$__schema.path(path);
    if (!_pathType) {
      continue;
    }

    if (!_pathType.$isMongooseArray ||
        // To avoid potential performance issues, skip doc arrays whose children
        // are not required. `getPositionalPathType()` may be slow, so avoid
        // it unless we have a case of #6364
        (!Array.isArray(_pathType) &&
          _pathType.$isMongooseDocumentArray &&
          !(_pathType && _pathType.schemaOptions && _pathType.schemaOptions.required))) {
      continue;
    }

    // gh-11380: optimization. If the array isn't a document array and there's no validators
    // on the array type, there's no need to run validation on the individual array elements.
    if (_pathType.$isMongooseArray &&
        !_pathType.$isMongooseDocumentArray && // Skip document arrays...
        !_pathType.$embeddedSchemaType.$isMongooseArray && // and arrays of arrays
        _pathType.$embeddedSchemaType.validators.length === 0) {
      continue;
    }

    const val = doc.$__getValue(path);
    _pushNestedArrayPaths(val, paths, path);
  }
}

function _pushNestedArrayPaths(val, paths, path) {
  if (val != null) {
    const numElements = val.length;
    for (let j = 0; j < numElements; ++j) {
      if (Array.isArray(val[j])) {
        _pushNestedArrayPaths(val[j], paths, path + '.' + j);
      } else {
        paths.add(path + '.' + j);
      }
    }
  }
>>>>>>> origin/wsj
}

/*!
 * ignore
 */

Document.prototype.$__validate = function(pathsToValidate, options, callback) {
<<<<<<< HEAD
  if (typeof pathsToValidate === 'function') {
=======
  if (this.$__.saveOptions && this.$__.saveOptions.pathsToSave && !pathsToValidate) {
    pathsToValidate = [...this.$__.saveOptions.pathsToSave];
  } else if (typeof pathsToValidate === 'function') {
>>>>>>> origin/wsj
    callback = pathsToValidate;
    options = null;
    pathsToValidate = null;
  } else if (typeof options === 'function') {
    callback = options;
    options = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

<<<<<<< HEAD
  const pathsToSkip = get(options, 'pathsToSkip', null);
=======
  const pathsToSkip = (options && options.pathsToSkip) || null;
>>>>>>> origin/wsj

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
  }

<<<<<<< HEAD
  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = undefined;
=======
  const validateAllPaths = options && options.validateAllPaths;
  if (validateAllPaths) {
    if (pathsToSkip) {
      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToSkip`');
    }
    if (pathsToValidate) {
      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToValidate`');
    }
    if (hasValidateModifiedOnlyOption && shouldValidateModifiedOnly) {
      throw new TypeError('Cannot set both `validateAllPaths` and `validateModifiedOnly`');
    }
  }

  const _this = this;
  const _complete = () => {
    let validationError = this.$__.validationError;
    this.$__.validationError = null;
    this.$__.validating = null;
>>>>>>> origin/wsj

    if (shouldValidateModifiedOnly && validationError != null) {
      // Remove any validation errors that aren't from modified paths
      const errors = Object.keys(validationError.errors);
      for (const errPath of errors) {
<<<<<<< HEAD
        if (!this.isModified(errPath)) {
=======
        if (!this.$isModified(errPath)) {
>>>>>>> origin/wsj
          delete validationError.errors[errPath];
        }
      }
      if (Object.keys(validationError.errors).length === 0) {
        validationError = void 0;
      }
    }

    this.$__.cachedRequired = {};
<<<<<<< HEAD
    this.emit('validate', _this);
    this.constructor.emit('validate', _this);

    this.$__.validating = null;
=======
    this.$emit('validate', _this);
    this.constructor.emit('validate', _this);

>>>>>>> origin/wsj
    if (validationError) {
      for (const key in validationError.errors) {
        // Make sure cast errors persist
        if (!this[documentArrayParent] &&
            validationError.errors[key] instanceof MongooseError.CastError) {
          this.invalidate(key, validationError.errors[key]);
        }
      }

      return validationError;
    }
  };

  // only validate required fields when necessary
<<<<<<< HEAD
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];
  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }
  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  } else if (pathsToSkip) {
    paths = _handlePathsToSkip(paths, pathsToSkip);
  }
=======
  let paths;
  let doValidateOptionsByPath;
  if (validateAllPaths) {
    paths = new Set(Object.keys(this.$__schema.paths));
    // gh-661: if a whole array is modified, make sure to run validation on all
    // the children as well
    for (const path of paths) {
      const schemaType = this.$__schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray) {
        continue;
      }
      const val = this.$__getValue(path);
      if (!val) {
        continue;
      }
      _pushNestedArrayPaths(val, paths, path);
    }
    paths = [...paths];
    doValidateOptionsByPath = {};
  } else {
    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip, options && options._nestedValidate);
    paths = shouldValidateModifiedOnly ?
      pathDetails[0].filter((path) => this.$isModified(path)) :
      pathDetails[0];
    doValidateOptionsByPath = pathDetails[1];
  }

  if (typeof pathsToValidate === 'string') {
    pathsToValidate = pathsToValidate.split(' ');
  }

>>>>>>> origin/wsj
  if (paths.length === 0) {
    return immediate(function() {
      const error = _complete();
      if (error) {
        return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
          callback(error);
        });
      }
      callback(null, _this);
    });
  }

  const validated = {};
  let total = 0;

<<<<<<< HEAD
  for (const path of paths) {
    validatePath(path);
=======
  let pathsToSave = this.$__.saveOptions?.pathsToSave;
  if (Array.isArray(pathsToSave)) {
    pathsToSave = new Set(pathsToSave);
    for (const path of paths) {
      if (!pathsToSave.has(path)) {
        continue;
      }
      validatePath(path);
    }
  } else {
    for (const path of paths) {
      validatePath(path);
    }
>>>>>>> origin/wsj
  }

  function validatePath(path) {
    if (path == null || validated[path]) {
      return;
    }

    validated[path] = true;
    total++;

    immediate(function() {
      const schemaType = _this.$__schema.path(path);

      if (!schemaType) {
        return --total || complete();
      }

      // If user marked as invalid or there was a cast error, don't validate
      if (!_this.$isValid(path)) {
        --total || complete();
        return;
      }

      // If setting a path under a mixed path, avoid using the mixed path validator (gh-10141)
      if (schemaType[schemaMixedSymbol] != null && path !== schemaType.path) {
        return --total || complete();
      }

      let val = _this.$__getValue(path);

      // If you `populate()` and get back a null value, required validators
      // shouldn't fail (gh-8018). We should always fall back to the populated
      // value.
      let pop;
<<<<<<< HEAD
      if (val == null && (pop = _this.populated(path))) {
        val = pop;
      }
      const scope = path in _this.$__.pathsToScopes ?
=======
      if ((pop = _this.$populated(path))) {
        val = pop;
      } else if (val != null && val.$__ != null && val.$__.wasPopulated) {
        // Array paths, like `somearray.1`, do not show up as populated with `$populated()`,
        // so in that case pull out the document's id
        val = val._doc._id;
      }
      const scope = _this.$__.pathsToScopes != null && path in _this.$__.pathsToScopes ?
>>>>>>> origin/wsj
        _this.$__.pathsToScopes[path] :
        _this;

      const doValidateOptions = {
<<<<<<< HEAD
        skipSchemaValidators: skipSchemaValidators[path],
        path: path,
        validateModifiedOnly: shouldValidateModifiedOnly
      };
      schemaType.doValidate(val, function(err) {
        if (err && (!schemaType.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
          if (schemaType.$isSingleNested &&
              err instanceof ValidationError &&
              schemaType.schema.options.storeSubdocValidationError === false) {
=======
        ...doValidateOptionsByPath[path],
        path: path,
        validateAllPaths,
        _nestedValidate: true
      };

      schemaType.doValidate(val, function(err) {
        if (err) {
          const isSubdoc = schemaType.$isSingleNested ||
              schemaType.$isArraySubdocument ||
              schemaType.$isMongooseDocumentArray;
          if (isSubdoc && err instanceof ValidationError) {
>>>>>>> origin/wsj
            return --total || complete();
          }
          _this.invalidate(path, err, undefined, true);
        }
        --total || complete();
      }, scope, doValidateOptions);
    });
  }

  function complete() {
    const error = _complete();
    if (error) {
      return _this.$__schema.s.hooks.execPost('validate:error', _this, [_this], { error: error }, function(error) {
        callback(error);
      });
    }
    callback(null, _this);
  }

};

/*!
 * ignore
 */

function _handlePathsToValidate(paths, pathsToValidate) {
  const _pathsToValidate = new Set(pathsToValidate);
  const parentPaths = new Map([]);
  for (const path of pathsToValidate) {
    if (path.indexOf('.') === -1) {
      continue;
    }
    const pieces = path.split('.');
    let cur = pieces[0];
    for (let i = 1; i < pieces.length; ++i) {
      // Since we skip subpaths under single nested subdocs to
      // avoid double validation, we need to add back the
      // single nested subpath if the user asked for it (gh-8626)
      parentPaths.set(cur, path);
      cur = cur + '.' + pieces[i];
    }
  }

<<<<<<< HEAD
  const ret = [];
  for (const path of paths) {
    if (_pathsToValidate.has(path)) {
      ret.push(path);
    } else if (parentPaths.has(path)) {
      ret.push(parentPaths.get(path));
=======
  const ret = new Set();
  for (const path of paths) {
    if (_pathsToValidate.has(path)) {
      ret.add(path);
    } else if (parentPaths.has(path)) {
      ret.add(parentPaths.get(path));
>>>>>>> origin/wsj
    }
  }
  return ret;
}

/*!
 * ignore
 */
<<<<<<< HEAD
function _handlePathsToSkip(paths, pathsToSkip) {
  pathsToSkip = new Set(pathsToSkip);
  paths = paths.filter(p => !pathsToSkip.has(p));
  return paths;
=======

function _handlePathsToSkip(paths, pathsToSkip) {
  pathsToSkip = new Set(pathsToSkip);
  paths = Array.from(paths).filter(p => !pathsToSkip.has(p));
  return new Set(paths);
>>>>>>> origin/wsj
}

/**
 * Executes registered validation rules (skipping asynchronous validators) for this document.
 *
<<<<<<< HEAD
 * ####Note:
 *
 * This method is useful if you need synchronous validation.
 *
 * ####Example:
=======
 * #### Note:
 *
 * This method is useful if you need synchronous validation.
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     const err = doc.validateSync();
 *     if (err) {
 *       handleError(err);
 *     } else {
 *       // validation passed
 *     }
 *
<<<<<<< HEAD
 * @param {Array|string} pathsToValidate only validate the given paths
=======
 * @param {Array|string} [pathsToValidate] only validate the given paths
>>>>>>> origin/wsj
 * @param {Object} [options] options for validation
 * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Array|string} [options.pathsToSkip] list of paths to skip. If set, Mongoose will validate every modified path that is not in this list.
 * @return {ValidationError|undefined} ValidationError if there are errors during validation, or undefined if there is no error.
 * @api public
 */

Document.prototype.validateSync = function(pathsToValidate, options) {
  const _this = this;

  if (arguments.length === 1 && typeof arguments[0] === 'object' && !Array.isArray(arguments[0])) {
    options = arguments[0];
    pathsToValidate = null;
  }

  const hasValidateModifiedOnlyOption = options &&
      (typeof options === 'object') &&
      ('validateModifiedOnly' in options);

  let shouldValidateModifiedOnly;
  if (hasValidateModifiedOnlyOption) {
    shouldValidateModifiedOnly = !!options.validateModifiedOnly;
  } else {
    shouldValidateModifiedOnly = this.$__schema.options.validateModifiedOnly;
  }

  let pathsToSkip = options && options.pathsToSkip;

<<<<<<< HEAD
=======
  const validateAllPaths = options && options.validateAllPaths;
  if (validateAllPaths) {
    if (pathsToSkip) {
      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToSkip`');
    }
    if (pathsToValidate) {
      throw new TypeError('Cannot set both `validateAllPaths` and `pathsToValidate`');
    }
  }

>>>>>>> origin/wsj
  if (typeof pathsToValidate === 'string') {
    const isOnePathOnly = pathsToValidate.indexOf(' ') === -1;
    pathsToValidate = isOnePathOnly ? [pathsToValidate] : pathsToValidate.split(' ');
  } else if (typeof pathsToSkip === 'string' && pathsToSkip.indexOf(' ') !== -1) {
    pathsToSkip = pathsToSkip.split(' ');
  }

  // only validate required fields when necessary
<<<<<<< HEAD
  const pathDetails = _getPathsToValidate(this);
  let paths = shouldValidateModifiedOnly ?
    pathDetails[0].filter((path) => this.isModified(path)) :
    pathDetails[0];
  const skipSchemaValidators = pathDetails[1];

  if (Array.isArray(pathsToValidate)) {
    paths = _handlePathsToValidate(paths, pathsToValidate);
  } else if (Array.isArray(pathsToSkip)) {
    paths = _handlePathsToSkip(paths, pathsToSkip);
  }
  const validating = {};

  paths.forEach(function(path) {
    if (validating[path]) {
      return;
=======
  let paths;
  let skipSchemaValidators;
  if (validateAllPaths) {
    paths = new Set(Object.keys(this.$__schema.paths));
    // gh-661: if a whole array is modified, make sure to run validation on all
    // the children as well
    for (const path of paths) {
      const schemaType = this.$__schema.path(path);
      if (!schemaType || !schemaType.$isMongooseArray) {
        continue;
      }
      const val = this.$__getValue(path);
      if (!val) {
        continue;
      }
      _pushNestedArrayPaths(val, paths, path);
    }
    paths = [...paths];
    skipSchemaValidators = {};
  } else {
    const pathDetails = _getPathsToValidate(this, pathsToValidate, pathsToSkip);
    paths = shouldValidateModifiedOnly ?
      pathDetails[0].filter((path) => this.$isModified(path)) :
      pathDetails[0];
    skipSchemaValidators = pathDetails[1];
  }

  const validating = {};

  for (let i = 0, len = paths.length; i < len; ++i) {
    const path = paths[i];

    if (validating[path]) {
      continue;
>>>>>>> origin/wsj
    }

    validating[path] = true;

    const p = _this.$__schema.path(path);
    if (!p) {
<<<<<<< HEAD
      return;
    }
    if (!_this.$isValid(path)) {
      return;
=======
      continue;
    }
    if (!_this.$isValid(path)) {
      continue;
>>>>>>> origin/wsj
    }

    const val = _this.$__getValue(path);
    const err = p.doValidateSync(val, _this, {
      skipSchemaValidators: skipSchemaValidators[path],
      path: path,
<<<<<<< HEAD
      validateModifiedOnly: shouldValidateModifiedOnly
    });
    if (err && (!p.$isMongooseDocumentArray || err.$isArrayValidatorError)) {
      if (p.$isSingleNested &&
          err instanceof ValidationError &&
          p.schema.options.storeSubdocValidationError === false) {
        return;
      }
      _this.invalidate(path, err, undefined, true);
    }
  });

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.emit('validate', _this);
=======
      validateModifiedOnly: shouldValidateModifiedOnly,
      validateAllPaths
    });
    if (err) {
      const isSubdoc = p.$isSingleNested ||
        p.$isArraySubdocument ||
        p.$isMongooseDocumentArray;
      if (isSubdoc && err instanceof ValidationError) {
        continue;
      }
      _this.invalidate(path, err, undefined, true);
    }
  }

  const err = _this.$__.validationError;
  _this.$__.validationError = undefined;
  _this.$emit('validate', _this);
>>>>>>> origin/wsj
  _this.constructor.emit('validate', _this);

  if (err) {
    for (const key in err.errors) {
      // Make sure cast errors persist
      if (err.errors[key] instanceof MongooseError.CastError) {
        _this.invalidate(key, err.errors[key]);
      }
    }
  }

  return err;
};

/**
 * Marks a path as invalid, causing validation to fail.
 *
 * The `errorMsg` argument will become the message of the `ValidationError`.
 *
 * The `value` argument (if passed) will be available through the `ValidationError.value` property.
 *
 *     doc.invalidate('size', 'must be less than 20', 14);
<<<<<<< HEAD

=======
 *
>>>>>>> origin/wsj
 *     doc.validate(function (err) {
 *       console.log(err)
 *       // prints
 *       { message: 'Validation failed',
 *         name: 'ValidationError',
 *         errors:
 *          { size:
 *             { message: 'must be less than 20',
 *               name: 'ValidatorError',
 *               path: 'size',
 *               type: 'user defined',
 *               value: 14 } } }
 *     })
 *
 * @param {String} path the field to invalidate. For array elements, use the `array.i.field` syntax, where `i` is the 0-based index in the array.
<<<<<<< HEAD
 * @param {String|Error} errorMsg the error which states the reason `path` was invalid
 * @param {Object|String|Number|any} value optional invalid value
=======
 * @param {String|Error} err the error which states the reason `path` was invalid
 * @param {Object|String|Number|any} val optional invalid value
>>>>>>> origin/wsj
 * @param {String} [kind] optional `kind` property for the error
 * @return {ValidationError} the current ValidationError, with all currently invalidated paths
 * @api public
 */

Document.prototype.invalidate = function(path, err, val, kind) {
  if (!this.$__.validationError) {
    this.$__.validationError = new ValidationError(this);
  }

  if (this.$__.validationError.errors[path]) {
    return;
  }

  if (!err || typeof err === 'string') {
    err = new ValidatorError({
      path: path,
      message: err,
      type: kind || 'user defined',
      value: val
    });
  }

  if (this.$__.validationError === err) {
    return this.$__.validationError;
  }

  this.$__.validationError.addError(path, err);
  return this.$__.validationError;
};

/**
 * Marks a path as valid, removing existing validation errors.
 *
 * @param {String} path the field to mark as valid
 * @api public
 * @memberOf Document
 * @instance
 * @method $markValid
 */

Document.prototype.$markValid = function(path) {
  if (!this.$__.validationError || !this.$__.validationError.errors[path]) {
    return;
  }

  delete this.$__.validationError.errors[path];
  if (Object.keys(this.$__.validationError.errors).length === 0) {
    this.$__.validationError = null;
  }
};

/*!
 * ignore
 */

function _markValidSubpaths(doc, path) {
  if (!doc.$__.validationError) {
    return;
  }

  const keys = Object.keys(doc.$__.validationError.errors);
  for (const key of keys) {
    if (key.startsWith(path + '.')) {
      delete doc.$__.validationError.errors[key];
    }
  }
  if (Object.keys(doc.$__.validationError.errors).length === 0) {
    doc.$__.validationError = null;
  }
}

/*!
 * ignore
 */

function _checkImmutableSubpaths(subdoc, schematype, priorVal) {
  const schema = schematype.schema;
  if (schema == null) {
    return;
  }

  for (const key of Object.keys(schema.paths)) {
    const path = schema.paths[key];
    if (path.$immutableSetter == null) {
      continue;
    }
    const oldVal = priorVal == null ? void 0 : priorVal.$__getValue(key);
    // Calling immutableSetter with `oldVal` even though it expects `newVal`
    // is intentional. That's because `$immutableSetter` compares its param
    // to the current value.
    path.$immutableSetter.call(subdoc, oldVal);
  }
}

/**
<<<<<<< HEAD
 * Saves this document by inserting a new document into the database if [document.isNew](/docs/api.html#document_Document-isNew) is `true`,
 * or sends an [updateOne](/docs/api.html#document_Document-updateOne) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.
 *
 * ####Example:
=======
 * Saves this document by inserting a new document into the database if [document.isNew](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) is `true`,
 * or sends an [updateOne](https://mongoosejs.com/docs/api/document.html#Document.prototype.updateOne()) operation **only** with the modifications to the database, it does not replace the whole document in the latter case.
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     product.sold = Date.now();
 *     product = await product.save();
 *
 * If save is successful, the returned promise will fulfill with the document
 * saved.
 *
<<<<<<< HEAD
 * ####Example:
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     const newProduct = await product.save();
 *     newProduct === product; // true
 *
 * @param {Object} [options] options optional options
<<<<<<< HEAD
 * @param {Session} [options.session=null] the [session](https://docs.mongodb.com/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](api.html#document_Document-$session).
 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](http://mongoosejs.com//docs/guide.html#safe). Use the `w` option instead.
 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
 * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Number|String} [options.w] set the [write concern](https://docs.mongodb.com/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://docs.mongodb.com/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern)
 * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://docs.mongodb.com/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](/docs/guide.html#writeConcern).
 * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://docs.mongodb.com/manual/reference/limits/#Restrictions-on-Field-Names)
 * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](./guide.html#timestamps) are enabled, skip timestamps for this `save()`.
 * @param {Function} [fn] optional callback
 * @method save
 * @memberOf Document
 * @instance
 * @throws {DocumentNotFoundError} if this [save updates an existing document](api.html#document_Document-isNew) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).
 * @return {Promise|undefined} Returns undefined if used with callback or a Promise otherwise.
 * @api public
 * @see middleware http://mongoosejs.com/docs/middleware.html
=======
 * @param {Session} [options.session=null] the [session](https://www.mongodb.com/docs/manual/reference/server-sessions/) associated with this save operation. If not specified, defaults to the [document's associated session](https://mongoosejs.com/docs/api/document.html#Document.prototype.$session()).
 * @param {Object} [options.safe] (DEPRECATED) overrides [schema's safe option](https://mongoosejs.com/docs/guide.html#safe). Use the `w` option instead.
 * @param {Boolean} [options.validateBeforeSave] set to false to save without validating.
 * @param {Boolean} [options.validateModifiedOnly=false] If `true`, Mongoose will only validate modified paths, as opposed to modified paths and `required` paths.
 * @param {Number|String} [options.w] set the [write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#w-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)
 * @param {Boolean} [options.j] set to true for MongoDB to wait until this `save()` has been [journaled before resolving the returned promise](https://www.mongodb.com/docs/manual/reference/write-concern/#j-option). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern)
 * @param {Number} [options.wtimeout] sets a [timeout for the write concern](https://www.mongodb.com/docs/manual/reference/write-concern/#wtimeout). Overrides the [schema-level `writeConcern` option](https://mongoosejs.com/docs/guide.html#writeConcern).
 * @param {Boolean} [options.checkKeys=true] the MongoDB driver prevents you from saving keys that start with '$' or contain '.' by default. Set this option to `false` to skip that check. See [restrictions on field names](https://www.mongodb.com/docs/manual/reference/limits/#Restrictions-on-Field-Names)
 * @param {Boolean} [options.timestamps=true] if `false` and [timestamps](https://mongoosejs.com/docs/guide.html#timestamps) are enabled, skip timestamps for this `save()`.
 * @method save
 * @memberOf Document
 * @instance
 * @throws {DocumentNotFoundError} if this [save updates an existing document](https://mongoosejs.com/docs/api/document.html#Document.prototype.isNew()) but the document doesn't exist in the database. For example, you will get this error if the document is [deleted between when you retrieved the document and when you saved it](documents.html#updating).
 * @return {Promise}
 * @api public
 * @see middleware https://mongoosejs.com/docs/middleware.html
>>>>>>> origin/wsj
 */

/**
 * Checks if a path is invalid
 *
<<<<<<< HEAD
 * @param {String|Array<String>} path the field to check
=======
 * @param {String|String[]} [path] the field to check. If unset will always return "false"
>>>>>>> origin/wsj
 * @method $isValid
 * @memberOf Document
 * @instance
 * @api private
 */

Document.prototype.$isValid = function(path) {
  if (this.$__.validationError == null || Object.keys(this.$__.validationError.errors).length === 0) {
    return true;
  }
  if (path == null) {
    return false;
  }

  if (path.indexOf(' ') !== -1) {
    path = path.split(' ');
  }
  if (Array.isArray(path)) {
    return path.some(p => this.$__.validationError.errors[p] == null);
  }

  return this.$__.validationError.errors[path] == null;
};

/**
 * Resets the internal modified state of this document.
 *
 * @api private
<<<<<<< HEAD
 * @return {Document}
=======
 * @return {Document} this
>>>>>>> origin/wsj
 * @method $__reset
 * @memberOf Document
 * @instance
 */

Document.prototype.$__reset = function reset() {
  let _this = this;
<<<<<<< HEAD
  DocumentArray || (DocumentArray = require('./types/documentarray'));

  this.$__.activePaths
    .map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    })
    .filter(function(val) {
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
    })
    .forEach(function(array) {
      let i = array.length;
      while (i--) {
        const doc = array[i];
        if (!doc) {
          continue;
        }
        doc.$__reset();
      }

      _this.$__.activePaths.init(array.$path());

      array[arrayAtomicsBackupSymbol] = array[arrayAtomicsSymbol];
      array[arrayAtomicsSymbol] = {};
    });

  this.$__.activePaths.
    map('init', 'modify', function(i) {
      return _this.$__getValue(i);
    }).
    filter(function(val) {
      return val && val.$isSingleNested;
    }).
    forEach(function(doc) {
      doc.$__reset();
      if (doc.$__parent === _this) {
        _this.$__.activePaths.init(doc.$basePath);
      } else if (doc.$__parent != null && doc.$__parent.ownerDocument) {
        // If map path underneath subdocument, may end up with a case where
        // map path is modified but parent still needs to be reset. See gh-10295
        doc.$__parent.$__reset();
      }
    });
=======

  // Skip for subdocuments
  const subdocs = !this.$isSubdocument ? this.$getAllSubdocs({ useCache: true }) : null;
  if (subdocs && subdocs.length > 0) {
    for (const subdoc of subdocs) {
      subdoc.$__reset();
    }
  }
>>>>>>> origin/wsj

  // clear atomics
  this.$__dirty().forEach(function(dirt) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol]) {
      type[arrayAtomicsBackupSymbol] = type[arrayAtomicsSymbol];
      type[arrayAtomicsSymbol] = {};
    }
  });

  this.$__.backup = {};
  this.$__.backup.activePaths = {
<<<<<<< HEAD
    modify: Object.assign({}, this.$__.activePaths.states.modify),
    default: Object.assign({}, this.$__.activePaths.states.default)
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.errors;
=======
    modify: Object.assign({}, this.$__.activePaths.getStatePaths('modify')),
    default: Object.assign({}, this.$__.activePaths.getStatePaths('default'))
  };
  this.$__.backup.validationError = this.$__.validationError;
  this.$__.backup.errors = this.$errors;
>>>>>>> origin/wsj

  // Clear 'dirty' cache
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('default');
  this.$__.validationError = undefined;
<<<<<<< HEAD
  this.errors = undefined;
=======
  this.$errors = undefined;
>>>>>>> origin/wsj
  _this = this;
  this.$__schema.requiredPaths().forEach(function(path) {
    _this.$__.activePaths.require(path);
  });

  return this;
};

/*!
 * ignore
 */

Document.prototype.$__undoReset = function $__undoReset() {
  if (this.$__.backup == null || this.$__.backup.activePaths == null) {
    return;
  }

  this.$__.activePaths.states.modify = this.$__.backup.activePaths.modify;
  this.$__.activePaths.states.default = this.$__.backup.activePaths.default;

  this.$__.validationError = this.$__.backup.validationError;
<<<<<<< HEAD
  this.errors = this.$__.backup.errors;
=======
  this.$errors = this.$__.backup.errors;
>>>>>>> origin/wsj

  for (const dirt of this.$__dirty()) {
    const type = dirt.value;

    if (type && type[arrayAtomicsSymbol] && type[arrayAtomicsBackupSymbol]) {
      type[arrayAtomicsSymbol] = type[arrayAtomicsBackupSymbol];
    }
  }

  for (const subdoc of this.$getAllSubdocs()) {
    subdoc.$__undoReset();
  }
};

/**
 * Returns this documents dirty paths / vals.
 *
<<<<<<< HEAD
=======
 * @return {Array}
>>>>>>> origin/wsj
 * @api private
 * @method $__dirty
 * @memberOf Document
 * @instance
 */

Document.prototype.$__dirty = function() {
  const _this = this;
<<<<<<< HEAD

=======
>>>>>>> origin/wsj
  let all = this.$__.activePaths.map('modify', function(path) {
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  });
<<<<<<< HEAD
=======

>>>>>>> origin/wsj
  // gh-2558: if we had to set a default and the value is not undefined,
  // we have to save as well
  all = all.concat(this.$__.activePaths.map('default', function(path) {
    if (path === '_id' || _this.$__getValue(path) == null) {
      return;
    }
    return {
      path: path,
      value: _this.$__getValue(path),
      schema: _this.$__path(path)
    };
  }));

<<<<<<< HEAD
  // Sort dirty paths in a flat hierarchy.
  all.sort(function(a, b) {
    return (a.path < b.path ? -1 : (a.path > b.path ? 1 : 0));
  });

  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
  let lastPath;
  let top;
=======
  const allPaths = new Map(all.filter((el) => el != null).map((el) => [el.path, el.value]));
  // Ignore "foo.a" if "foo" is dirty already.
  const minimal = [];
>>>>>>> origin/wsj

  all.forEach(function(item) {
    if (!item) {
      return;
    }
<<<<<<< HEAD
    if (lastPath == null || item.path.indexOf(lastPath) !== 0) {
      lastPath = item.path + '.';
      minimal.push(item);
      top = item;
    } else if (top != null &&
        top.value != null &&
        top.value[arrayAtomicsSymbol] != null &&
        top.value.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being modified.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top.value[arrayAtomicsSymbol] = {};
      top.value[arrayAtomicsSymbol].$set = top.value;
    }
  });
  top = lastPath = null;
=======

    let top = null;

    const array = parentPaths(item.path);
    for (let i = 0; i < array.length - 1; i++) {
      if (allPaths.has(array[i])) {
        top = allPaths.get(array[i]);
        break;
      }
    }
    if (top == null) {
      minimal.push(item);
    } else if (top != null &&
        top[arrayAtomicsSymbol] != null &&
        top.hasAtomics()) {
      // special case for top level MongooseArrays
      // the `top` array itself and a sub path of `top` are being set.
      // the only way to honor all of both modifications is through a $set
      // of entire array.
      top[arrayAtomicsSymbol] = {};
      top[arrayAtomicsSymbol].$set = top;
    }
  });
>>>>>>> origin/wsj
  return minimal;
};

/**
 * Assigns/compiles `schema` into this documents prototype.
 *
 * @param {Schema} schema
 * @api private
 * @method $__setSchema
 * @memberOf Document
 * @instance
 */

Document.prototype.$__setSchema = function(schema) {
<<<<<<< HEAD
  schema.plugin(idGetter, { deduplicate: true });
=======
>>>>>>> origin/wsj
  compile(schema.tree, this, undefined, schema.options);

  // Apply default getters if virtual doesn't have any (gh-6262)
  for (const key of Object.keys(schema.virtuals)) {
    schema.virtuals[key]._applyDefaultGetters();
  }
  if (schema.path('schema') == null) {
    this.schema = schema;
  }
  this.$__schema = schema;
  this[documentSchemaSymbol] = schema;
};


/**
 * Get active path that were changed and are arrays
 *
<<<<<<< HEAD
=======
 * @return {Array}
>>>>>>> origin/wsj
 * @api private
 * @method $__getArrayPathsToValidate
 * @memberOf Document
 * @instance
 */

Document.prototype.$__getArrayPathsToValidate = function() {
<<<<<<< HEAD
  DocumentArray || (DocumentArray = require('./types/documentarray'));
=======
  DocumentArray || (DocumentArray = require('./types/documentArray'));
>>>>>>> origin/wsj

  // validate all document arrays.
  return this.$__.activePaths
    .map('init', 'modify', function(i) {
      return this.$__getValue(i);
    }.bind(this))
    .filter(function(val) {
<<<<<<< HEAD
      return val && val instanceof Array && val.isMongooseDocumentArray && val.length;
=======
      return val && Array.isArray(val) && utils.isMongooseDocumentArray(val) && val.length;
>>>>>>> origin/wsj
    }).reduce(function(seed, array) {
      return seed.concat(array);
    }, [])
    .filter(function(doc) {
      return doc;
    });
};


/**
 * Get all subdocs (by bfs)
 *
<<<<<<< HEAD
=======
 * @param {Object} [options] options. Currently for internal use.
 * @return {Array}
>>>>>>> origin/wsj
 * @api public
 * @method $getAllSubdocs
 * @memberOf Document
 * @instance
 */

<<<<<<< HEAD
Document.prototype.$getAllSubdocs = function $getAllSubdocs() {
  DocumentArray || (DocumentArray = require('./types/documentarray'));
  Embedded = Embedded || require('./types/embedded');

  function docReducer(doc, seed, path) {
    let val = doc;
    let isNested = false;
    if (path) {
      if (doc instanceof Document && doc[documentSchemaSymbol].paths[path]) {
        val = doc._doc[path];
      } else if (doc instanceof Document && doc[documentSchemaSymbol].nested[path]) {
        val = doc._doc[path];
        isNested = true;
      } else {
        val = doc[path];
      }
    }
    if (val instanceof Embedded) {
      seed.push(val);
    } else if (val instanceof Map) {
      seed = Array.from(val.keys()).reduce(function(seed, path) {
        return docReducer(val.get(path), seed, null);
      }, seed);
    } else if (val && val.$isSingleNested) {
      seed = Object.keys(val._doc).reduce(function(seed, path) {
        return docReducer(val._doc, seed, path);
      }, seed);
      seed.push(val);
    } else if (val && val.isMongooseDocumentArray) {
      val.forEach(function _docReduce(doc) {
        if (!doc || !doc._doc) {
          return;
        }
        seed = Object.keys(doc._doc).reduce(function(seed, path) {
          return docReducer(doc._doc, seed, path);
        }, seed);
        if (doc instanceof Embedded) {
          seed.push(doc);
        }
      });
    } else if (isNested && val != null) {
      for (const path of Object.keys(val)) {
        docReducer(val, seed, path);
      }
    }
    return seed;
  }

  const subDocs = [];
  for (const path of Object.keys(this._doc)) {
    docReducer(this, subDocs, path);
=======
Document.prototype.$getAllSubdocs = function(options) {
  if (options?.useCache && this.$__.saveOptions?.__subdocs) {
    return this.$__.saveOptions.__subdocs;
  }

  DocumentArray || (DocumentArray = require('./types/documentArray'));
  Embedded = Embedded || require('./types/arraySubdocument');

  const subDocs = [];
  function getSubdocs(doc) {
    const newSubdocs = [];

    for (const { model } of doc.$__schema.childSchemas) {
      // Avoid using `childSchemas.path` to avoid compatibility versions with pre-8.8 versions of Mongoose
      const val = doc.$__getValue(model.path);
      if (val == null) {
        continue;
      }
      if (val.$__) {
        newSubdocs.push(val);
      }
      if (Array.isArray(val)) {
        for (const el of val) {
          if (el != null && el.$__) {
            newSubdocs.push(el);
          }
        }
      }
      if (val instanceof Map) {
        for (const el of val.values()) {
          if (el != null && el.$__) {
            newSubdocs.push(el);
          }
        }
      }
    }

    for (const subdoc of newSubdocs) {
      getSubdocs(subdoc);
    }
    subDocs.push(...newSubdocs);
  }

  getSubdocs(this);

  if (this.$__.saveOptions) {
    this.$__.saveOptions.__subdocs = subDocs;
>>>>>>> origin/wsj
  }

  return subDocs;
};

/*!
 * Runs queued functions
 */

function applyQueue(doc) {
  const q = doc.$__schema && doc.$__schema.callQueue;
  if (!q.length) {
    return;
  }

  for (const pair of q) {
    if (pair[0] !== 'pre' && pair[0] !== 'post' && pair[0] !== 'on') {
      doc[pair[0]].apply(doc, pair[1]);
    }
  }
}

/*!
 * ignore
 */

Document.prototype.$__handleReject = function handleReject(err) {
  // emit on the Model if listening
<<<<<<< HEAD
  if (this.listeners('error').length) {
    this.emit('error', err);
=======
  if (this.$listeners('error').length) {
    this.$emit('error', err);
>>>>>>> origin/wsj
  } else if (this.constructor.listeners && this.constructor.listeners('error').length) {
    this.constructor.emit('error', err);
  }
};

/**
<<<<<<< HEAD
 * Internal helper for toObject() and toJSON() that doesn't manipulate options
 *
=======
 * Internal common logic for toObject() and toJSON()
 *
 * @return {Object}
>>>>>>> origin/wsj
 * @api private
 * @method $toObject
 * @memberOf Document
 * @instance
 */

Document.prototype.$toObject = function(options, json) {
<<<<<<< HEAD
  let defaultOptions = {
    transform: true,
    flattenDecimals: true
  };

  const path = json ? 'toJSON' : 'toObject';
  const baseOptions = get(this, 'constructor.base.options.' + path, {});
  const schemaOptions = get(this, '$__schema.options', {});
  // merge base default options with Schema's set default options if available.
  // `clone` is necessary here because `utils.options` directly modifies the second input.
  defaultOptions = utils.options(defaultOptions, clone(baseOptions));
  defaultOptions = utils.options(defaultOptions, clone(schemaOptions[path] || {}));

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? clone(options) : {};
  options._calledWithOptions = options._calledWithOptions || clone(options);
=======
  const defaultOptions = this.$__schema._defaultToObjectOptions(json);

  const hasOnlyPrimitiveValues = this.$__hasOnlyPrimitiveValues();

  // If options do not exist or is not an object, set it to empty object
  options = utils.isPOJO(options) ? { ...options } : {};
  options._calledWithOptions = options._calledWithOptions || { ...options };
>>>>>>> origin/wsj

  let _minimize;
  if (options._calledWithOptions.minimize != null) {
    _minimize = options.minimize;
<<<<<<< HEAD
  } else if (defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = schemaOptions.minimize;
  }

  let flattenMaps;
  if (options._calledWithOptions.flattenMaps != null) {
    flattenMaps = options.flattenMaps;
  } else if (defaultOptions.flattenMaps != null) {
    flattenMaps = defaultOptions.flattenMaps;
  } else {
    flattenMaps = schemaOptions.flattenMaps;
  }

  // The original options that will be passed to `clone()`. Important because
  // `clone()` will recursively call `$toObject()` on embedded docs, so we
  // need the original options the user passed in, plus `_isNested` and
  // `_parentOptions` for checking whether we need to depopulate.
  const cloneOptions = Object.assign(utils.clone(options), {
    _isNested: true,
    json: json,
    minimize: _minimize,
    flattenMaps: flattenMaps
  });

  if (utils.hasUserDefinedProperty(options, 'getters')) {
    cloneOptions.getters = options.getters;
  }
  if (utils.hasUserDefinedProperty(options, 'virtuals')) {
    cloneOptions.virtuals = options.virtuals;
  }

  const depopulate = options.depopulate ||
    get(options, '_parentOptions.depopulate', false);
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    // populated paths that we set to a document
    return clone(this._id, cloneOptions);
  }

  // merge default options with input options.
  options = utils.options(defaultOptions, options);
=======
  } else if (defaultOptions != null && defaultOptions.minimize != null) {
    _minimize = defaultOptions.minimize;
  } else {
    _minimize = this.$__schema.options.minimize;
  }

  options.minimize = _minimize;
  if (!hasOnlyPrimitiveValues) {
    options._seen = options._seen || new Map();
  }

  const depopulate = options._calledWithOptions.depopulate
    ?? defaultOptions?.depopulate
    ?? options.depopulate
    ?? false;
  // _isNested will only be true if this is not the top level document, we
  // should never depopulate the top-level document
  if (depopulate && options._isNested && this.$__.wasPopulated) {
    return clone(this.$__.wasPopulated.value || this._doc._id, options);
  }
  if (depopulate) {
    options.depopulate = true;
  }

  // merge default options with input options.
  if (defaultOptions != null) {
    for (const key of Object.keys(defaultOptions)) {
      if (options[key] == null) {
        options[key] = defaultOptions[key];
      }
    }
  }
>>>>>>> origin/wsj
  options._isNested = true;
  options.json = json;
  options.minimize = _minimize;

<<<<<<< HEAD
  cloneOptions._parentOptions = options;
  cloneOptions._skipSingleNestedGetters = true;

  const gettersOptions = Object.assign({}, cloneOptions);
  gettersOptions._skipSingleNestedGetters = false;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  const originalTransform = options.transform;

  let ret = clone(this._doc, cloneOptions) || {};

  if (options.getters) {
    applyGetters(this, ret, gettersOptions);
=======
  const parentOptions = options._parentOptions;
  // Parent options should only bubble down for subdocuments, not populated docs
  options._parentOptions = this.$isSubdocument ? options : null;

  // remember the root transform function
  // to save it from being overwritten by sub-transform functions
  // const originalTransform = options.transform;

  let ret;
  if (hasOnlyPrimitiveValues && !options.flattenObjectIds) {
    // Fast path: if we don't have any nested objects or arrays, we only need a
    // shallow clone.
    ret = this.$__toObjectShallow();
  } else {
    ret = clone(this._doc, options) || {};
  }

  const getters = options._calledWithOptions.getters
    ?? options.getters
    ?? defaultOptions.getters
    ?? false;

  if (getters) {
    applyGetters(this, ret);
>>>>>>> origin/wsj

    if (options.minimize) {
      ret = minimize(ret) || {};
    }
  }

<<<<<<< HEAD
  if (options.virtuals || (options.getters && options.virtuals !== false)) {
    applyVirtuals(this, ret, gettersOptions, options);
=======
  const virtuals = options._calledWithOptions.virtuals
    ?? defaultOptions.virtuals
    ?? parentOptions?.virtuals
    ?? undefined;

  if (virtuals || (getters && virtuals !== false)) {
    applyVirtuals(this, ret, options, options);
>>>>>>> origin/wsj
  }

  if (options.versionKey === false && this.$__schema.options.versionKey) {
    delete ret[this.$__schema.options.versionKey];
  }

<<<<<<< HEAD
  let transform = options.transform;
=======
  const transform = options._calledWithOptions.transform ?? true;
  let transformFunction = undefined;
  if (transform === true) {
    transformFunction = defaultOptions.transform;
  } else if (typeof transform === 'function') {
    transformFunction = transform;
  }
>>>>>>> origin/wsj

  // In the case where a subdocument has its own transform function, we need to
  // check and see if the parent has a transform (options.transform) and if the
  // child schema has a transform (this.schema.options.toObject) In this case,
  // we need to adjust options.transform to be the child schema's transform and
  // not the parent schema's
  if (transform) {
    applySchemaTypeTransforms(this, ret);
  }

  if (options.useProjection) {
    omitDeselectedFields(this, ret);
  }

<<<<<<< HEAD
  if (transform === true || (schemaOptions.toObject && transform)) {
    const opts = options.json ? schemaOptions.toJSON : schemaOptions.toObject;

    if (opts) {
      transform = (typeof options.transform === 'function' ? options.transform : opts.transform);
    }
  } else {
    options.transform = originalTransform;
  }

  if (typeof transform === 'function') {
    const xformed = transform(this, ret, options);
=======
  if (typeof transformFunction === 'function') {
    const xformed = transformFunction(this, ret, options);
>>>>>>> origin/wsj
    if (typeof xformed !== 'undefined') {
      ret = xformed;
    }
  }

  return ret;
};

<<<<<<< HEAD
/**
 * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).
 *
 * Buffers are converted to instances of [mongodb.Binary](http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html) for proper storage.
 *
 * ####Options:
 *
 * - `getters` apply all getters (path and virtual getters), defaults to false
 * - `aliases` apply all aliases if `virtuals=true`, defaults to true
 * - `virtuals` apply virtual getters (can override `getters` option), defaults to false
 * - `minimize` remove empty objects, defaults to true
 * - `transform` a transform function to apply to the resulting document before returning
 * - `depopulate` depopulate any populated paths, replacing them with their original refs, defaults to false
 * - `versionKey` whether to include the version key, defaults to true
 * - `flattenMaps` convert Maps to POJOs. Useful if you want to JSON.stringify() the result of toObject(), defaults to false
 * - `useProjection` set to `true` to omit fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.
 *
 * ####Getters/Virtuals
=======
/*!
 * Internal shallow clone alternative to `$toObject()`: much faster, no options processing
 */

Document.prototype.$__toObjectShallow = function $__toObjectShallow() {
  const ret = {};
  if (this._doc != null) {
    for (const key of Object.keys(this._doc)) {
      const value = this._doc[key];
      if (value instanceof Date) {
        ret[key] = new Date(value);
      } else if (value !== undefined) {
        ret[key] = value;
      }
    }
  }

  return ret;
};

/**
 * Converts this document into a plain-old JavaScript object ([POJO](https://masteringjs.io/tutorials/fundamentals/pojo)).
 *
 * Buffers are converted to instances of [mongodb.Binary](https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html) for proper storage.
 *
 * #### Getters/Virtuals
>>>>>>> origin/wsj
 *
 * Example of only applying path getters
 *
 *     doc.toObject({ getters: true, virtuals: false })
 *
 * Example of only applying virtual getters
 *
 *     doc.toObject({ virtuals: true })
 *
 * Example of applying both path and virtual getters
 *
 *     doc.toObject({ getters: true })
 *
<<<<<<< HEAD
 * To apply these options to every document of your schema by default, set your [schemas](#schema_Schema) `toObject` option to the same argument.
 *
 *     schema.set('toObject', { virtuals: true })
 *
 * ####Transform
=======
 * To apply these options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toObject` option to the same argument.
 *
 *     schema.set('toObject', { virtuals: true })
 *
 * #### Transform:
>>>>>>> origin/wsj
 *
 * We may need to perform a transformation of the resulting object based on some criteria, say to remove some sensitive information or return a custom object. In this case we set the optional `transform` function.
 *
 * Transform functions receive three arguments
 *
 *     function (doc, ret, options) {}
 *
 * - `doc` The mongoose document which is being converted
 * - `ret` The plain object representation which has been converted
 * - `options` The options in use (either schema options or the options passed inline)
 *
<<<<<<< HEAD
 * ####Example
=======
 * #### Example:
>>>>>>> origin/wsj
 *
 *     // specify the transform schema option
 *     if (!schema.options.toObject) schema.options.toObject = {};
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       // remove the _id of every document before returning the result
 *       delete ret._id;
 *       return ret;
 *     }
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
 *
 *     // with the transformation
 *     doc.toObject(); // { name: 'Wreck-it Ralph' }
 *
 * With transformations we can do a lot more than remove properties. We can even return completely new customized objects:
 *
 *     if (!schema.options.toObject) schema.options.toObject = {};
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       return { movie: ret.name }
 *     }
 *
 *     // without the transformation in the schema
 *     doc.toObject(); // { _id: 'anId', name: 'Wreck-it Ralph' }
 *
 *     // with the transformation
 *     doc.toObject(); // { movie: 'Wreck-it Ralph' }
 *
 * _Note: if a transform function returns `undefined`, the return value will be ignored._
 *
<<<<<<< HEAD
 * Transformations may also be applied inline, overridding any transform set in the options:
 *
 *     function xform (doc, ret, options) {
 *       return { inline: ret.name, custom: true }
 *     }
 *
 *     // pass the transform as an inline option
 *     doc.toObject({ transform: xform }); // { inline: 'Wreck-it Ralph', custom: true }
=======
 * Transformations may also be applied inline, overridding any transform set in the schema options.
 * Any transform function specified in `toObject` options also propagates to any subdocuments.
 *
 *     function deleteId(doc, ret, options) {
 *       delete ret._id;
 *       return ret;
 *     }
 *
 *     const schema = mongoose.Schema({ name: String, docArr: [{ name: String }] });
 *     const TestModel = mongoose.model('Test', schema);
 *
 *     const doc = new TestModel({ name: 'test', docArr: [{ name: 'test' }] });
 *
 *     // pass the transform as an inline option. Deletes `_id` property
 *     // from both the top-level document and the subdocument.
 *     const obj = doc.toObject({ transform: deleteId });
 *     obj._id; // undefined
 *     obj.docArr[0]._id; // undefined
>>>>>>> origin/wsj
 *
 * If you want to skip transformations, use `transform: false`:
 *
 *     schema.options.toObject.hide = '_id';
 *     schema.options.toObject.transform = function (doc, ret, options) {
 *       if (options.hide) {
 *         options.hide.split(' ').forEach(function (prop) {
 *           delete ret[prop];
 *         });
 *       }
 *       return ret;
 *     }
 *
 *     const doc = new Doc({ _id: 'anId', secret: 47, name: 'Wreck-it Ralph' });
 *     doc.toObject();                                        // { secret: 47, name: 'Wreck-it Ralph' }
 *     doc.toObject({ hide: 'secret _id', transform: false });// { _id: 'anId', secret: 47, name: 'Wreck-it Ralph' }
 *     doc.toObject({ hide: 'secret _id', transform: true }); // { name: 'Wreck-it Ralph' }
 *
 * If you pass a transform in `toObject()` options, Mongoose will apply the transform
<<<<<<< HEAD
 * to [subdocuments](/docs/subdocs.html) in addition to the top-level document.
 * Similarly, `transform: false` skips transforms for all subdocuments.
 * Note that this is behavior is different for transforms defined in the schema:
=======
 * to [subdocuments](https://mongoosejs.com/docs/subdocs.html) in addition to the top-level document.
 * Similarly, `transform: false` skips transforms for all subdocuments.
 * Note that this behavior is different for transforms defined in the schema:
>>>>>>> origin/wsj
 * if you define a transform in `schema.options.toObject.transform`, that transform
 * will **not** apply to subdocuments.
 *
 *     const memberSchema = new Schema({ name: String, email: String });
 *     const groupSchema = new Schema({ members: [memberSchema], name: String, email });
 *     const Group = mongoose.model('Group', groupSchema);
 *
 *     const doc = new Group({
 *       name: 'Engineering',
 *       email: 'dev@mongoosejs.io',
 *       members: [{ name: 'Val', email: 'val@mongoosejs.io' }]
 *     });
 *
 *     // Removes `email` from both top-level document **and** array elements
 *     // { name: 'Engineering', members: [{ name: 'Val' }] }
 *     doc.toObject({ transform: (doc, ret) => { delete ret.email; return ret; } });
 *
 * Transforms, like all of these options, are also available for `toJSON`. See [this guide to `JSON.stringify()`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html) to learn why `toJSON()` and `toObject()` are separate functions.
 *
<<<<<<< HEAD
 * See [schema options](/docs/guide.html#toObject) for some more details.
=======
 * See [schema options](https://mongoosejs.com/docs/guide.html#toObject) for some more details.
>>>>>>> origin/wsj
 *
 * _During save, no custom options are applied to the document before being sent to the database._
 *
 * @param {Object} [options]
 * @param {Boolean} [options.getters=false] if true, apply all getters, including virtuals
<<<<<<< HEAD
 * @param {Boolean} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals
=======
 * @param {Boolean|Object} [options.virtuals=false] if true, apply virtuals, including aliases. Use `{ getters: true, virtuals: false }` to just apply getters, not virtuals. An object of the form `{ pathsToSkip: ['someVirtual'] }` may also be used to omit specific virtuals.
>>>>>>> origin/wsj
 * @param {Boolean} [options.aliases=true] if `options.virtuals = true`, you can set `options.aliases = false` to skip applying aliases. This option is a no-op if `options.virtuals = false`.
 * @param {Boolean} [options.minimize=true] if true, omit any empty objects from the output
 * @param {Function|null} [options.transform=null] if set, mongoose will call this function to allow you to transform the returned object
 * @param {Boolean} [options.depopulate=false] if true, replace any conventionally populated paths with the original id in the output. Has no affect on virtual populated paths.
 * @param {Boolean} [options.versionKey=true] if false, exclude the version key (`__v` by default) from the output
 * @param {Boolean} [options.flattenMaps=false] if true, convert Maps to POJOs. Useful if you want to `JSON.stringify()` the result of `toObject()`.
<<<<<<< HEAD
 * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.
 * @return {Object} js object
 * @see mongodb.Binary http://mongodb.github.com/node-mongodb-native/api-bson-generated/binary.html
=======
 * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.
 * @param {Boolean} [options.useProjection=false] - If true, omits fields that are excluded in this document's projection. Unless you specified a projection, this will omit any field that has `select: false` in the schema.
 * @return {Object} js object (not a POJO)
 * @see mongodb.Binary https://mongodb.github.io/node-mongodb-native/4.9/classes/Binary.html
>>>>>>> origin/wsj
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.toObject = function(options) {
  return this.$toObject(options);
};

/*!
<<<<<<< HEAD
 * Minimizes an object, removing undefined values and empty objects
 *
 * @param {Object} object to minimize
 * @return {Object}
 */

function minimize(obj) {
  const keys = Object.keys(obj);
  let i = keys.length;
  let hasKeys;
  let key;
  let val;

  while (i--) {
    key = keys[i];
    val = obj[key];

    if (utils.isObject(val) && !Buffer.isBuffer(val)) {
      obj[key] = minimize(val);
    }

    if (undefined === obj[key]) {
      delete obj[key];
      continue;
    }

    hasKeys = true;
  }

  return hasKeys
    ? obj
    : undefined;
}

/*!
=======
>>>>>>> origin/wsj
 * Applies virtuals properties to `json`.
 */

function applyVirtuals(self, json, options, toObjectOptions) {
  const schema = self.$__schema;
<<<<<<< HEAD
  const paths = Object.keys(schema.virtuals);
=======
  const virtuals = schema.virtuals;
  const paths = Object.keys(virtuals);
>>>>>>> origin/wsj
  let i = paths.length;
  const numPaths = i;
  let path;
  let assignPath;
  let cur = self._doc;
  let v;
<<<<<<< HEAD
  const aliases = get(toObjectOptions, 'aliases', true);

  let virtualsToApply = null;
  if (Array.isArray(options.virtuals)) {
    virtualsToApply = new Set(options.virtuals);
  }
  else if (options.virtuals && options.virtuals.pathsToSkip) {
=======
  const aliases = typeof (toObjectOptions && toObjectOptions.aliases) === 'boolean'
    ? toObjectOptions.aliases
    : true;

  options = options || {};
  let virtualsToApply = null;
  if (Array.isArray(options.virtuals)) {
    virtualsToApply = new Set(options.virtuals);
  } else if (options.virtuals && options.virtuals.pathsToSkip) {
>>>>>>> origin/wsj
    virtualsToApply = new Set(paths);
    for (let i = 0; i < options.virtuals.pathsToSkip.length; i++) {
      if (virtualsToApply.has(options.virtuals.pathsToSkip[i])) {
        virtualsToApply.delete(options.virtuals.pathsToSkip[i]);
      }
    }
  }

  if (!cur) {
    return json;
  }

<<<<<<< HEAD
  options = options || {};
=======
>>>>>>> origin/wsj
  for (i = 0; i < numPaths; ++i) {
    path = paths[i];

    if (virtualsToApply != null && !virtualsToApply.has(path)) {
      continue;
    }

    // Allow skipping aliases with `toObject({ virtuals: true, aliases: false })`
    if (!aliases && schema.aliases.hasOwnProperty(path)) {
      continue;
    }

    // We may be applying virtuals to a nested object, for example if calling
    // `doc.nestedProp.toJSON()`. If so, the path we assign to, `assignPath`,
    // will be a trailing substring of the `path`.
    assignPath = path;
    if (options.path != null) {
      if (!path.startsWith(options.path + '.')) {
        continue;
      }
<<<<<<< HEAD
      assignPath = path.substr(options.path.length + 1);
=======
      assignPath = path.substring(options.path.length + 1);
    }
    if (assignPath.indexOf('.') === -1 && assignPath === path) {
      v = virtuals[path].applyGetters(void 0, self);
      if (v === void 0) {
        continue;
      }
      v = clone(v, options);
      json[assignPath] = v;
      continue;
>>>>>>> origin/wsj
    }
    const parts = assignPath.split('.');
    v = clone(self.get(path), options);
    if (v === void 0) {
      continue;
    }
    const plen = parts.length;
    cur = json;
    for (let j = 0; j < plen - 1; ++j) {
      cur[parts[j]] = cur[parts[j]] || {};
      cur = cur[parts[j]];
    }
    cur[parts[plen - 1]] = v;
  }

  return json;
}


<<<<<<< HEAD
/*!
=======
/**
>>>>>>> origin/wsj
 * Applies virtuals properties to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
<<<<<<< HEAD
 */

function applyGetters(self, json, options) {
=======
 * @api private
 */

function applyGetters(self, json) {
>>>>>>> origin/wsj
  const schema = self.$__schema;
  const paths = Object.keys(schema.paths);
  let i = paths.length;
  let path;
  let cur = self._doc;
  let v;

  if (!cur) {
    return json;
  }

  while (i--) {
    path = paths[i];

    const parts = path.split('.');
<<<<<<< HEAD
=======

>>>>>>> origin/wsj
    const plen = parts.length;
    const last = plen - 1;
    let branch = json;
    let part;
    cur = self._doc;

    if (!self.$__isSelected(path)) {
      continue;
    }

    for (let ii = 0; ii < plen; ++ii) {
      part = parts[ii];
      v = cur[part];
<<<<<<< HEAD
      if (ii === last) {
        const val = self.get(path);
        branch[part] = clone(val, options);
=======
      // If we've reached a non-object part of the branch, continuing would
      // cause "Cannot create property 'foo' on string 'bar'" error.
      // Necessary for mongoose-intl plugin re: gh-14446
      if (branch != null && typeof branch !== 'object') {
        break;
      } else if (ii === last) {
        branch[part] = schema.paths[path].applyGetters(
          branch[part],
          self
        );
        if (Array.isArray(branch[part]) && schema.paths[path].$embeddedSchemaType) {
          for (let i = 0; i < branch[part].length; ++i) {
            branch[part][i] = schema.paths[path].$embeddedSchemaType.applyGetters(
              branch[part][i],
              self
            );
          }
        }
>>>>>>> origin/wsj
      } else if (v == null) {
        if (part in cur) {
          branch[part] = v;
        }
        break;
      } else {
        branch = branch[part] || (branch[part] = {});
      }
      cur = v;
    }
  }

  return json;
}

<<<<<<< HEAD
/*!
=======
/**
>>>>>>> origin/wsj
 * Applies schema type transforms to `json`.
 *
 * @param {Document} self
 * @param {Object} json
 * @return {Object} `json`
<<<<<<< HEAD
=======
 * @api private
>>>>>>> origin/wsj
 */

function applySchemaTypeTransforms(self, json) {
  const schema = self.$__schema;
  const paths = Object.keys(schema.paths || {});
  const cur = self._doc;

  if (!cur) {
    return json;
  }

  for (const path of paths) {
    const schematype = schema.paths[path];
    if (typeof schematype.options.transform === 'function') {
<<<<<<< HEAD
      const val = self.get(path);
=======
      const val = self.$get(path);
      if (val === undefined) {
        continue;
      }
>>>>>>> origin/wsj
      const transformedValue = schematype.options.transform.call(self, val);
      throwErrorIfPromise(path, transformedValue);
      utils.setValue(path, transformedValue, json);
    } else if (schematype.$embeddedSchemaType != null &&
        typeof schematype.$embeddedSchemaType.options.transform === 'function') {
<<<<<<< HEAD
      const vals = [].concat(self.get(path));
=======
      const val = self.$get(path);
      if (val === undefined) {
        continue;
      }
      const vals = [].concat(val);
>>>>>>> origin/wsj
      const transform = schematype.$embeddedSchemaType.options.transform;
      for (let i = 0; i < vals.length; ++i) {
        const transformedValue = transform.call(self, vals[i]);
        vals[i] = transformedValue;
        throwErrorIfPromise(path, transformedValue);
      }

      json[path] = vals;
    }
  }

  return json;
}

function throwErrorIfPromise(path, transformedValue) {
  if (isPromise(transformedValue)) {
    throw new Error('`transform` function must be synchronous, but the transform on path `' + path + '` returned a promise.');
  }
}

/*!
 * ignore
 */

function omitDeselectedFields(self, json) {
  const schema = self.$__schema;
  const paths = Object.keys(schema.paths || {});
  const cur = self._doc;

  if (!cur) {
    return json;
  }

  let selected = self.$__.selected;
  if (selected === void 0) {
    selected = {};
    queryhelpers.applyPaths(selected, schema);
  }
  if (selected == null || Object.keys(selected).length === 0) {
    return json;
  }

  for (const path of paths) {
    if (selected[path] != null && !selected[path]) {
      delete json[path];
    }
  }

  return json;
}

/**
<<<<<<< HEAD
 * The return value of this method is used in calls to JSON.stringify(doc).
 *
 * This method accepts the same options as [Document#toObject](#document_Document-toObject). To apply the options to every document of your schema by default, set your [schemas](#schema_Schema) `toJSON` option to the same argument.
 *
 *     schema.set('toJSON', { virtuals: true })
 *
 * See [schema options](/docs/guide.html#toJSON) for details.
 *
 * @param {Object} options
 * @return {Object}
 * @see Document#toObject #document_Document-toObject
=======
 * The return value of this method is used in calls to [`JSON.stringify(doc)`](https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript#the-tojson-function).
 *
 * This method accepts the same options as [Document#toObject](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()). To apply the options to every document of your schema by default, set your [schemas](https://mongoosejs.com/docs/api/schema.html#Schema()) `toJSON` option to the same argument.
 *
 *     schema.set('toJSON', { virtuals: true });
 *
 * There is one difference between `toJSON()` and `toObject()` options.
 * When you call `toJSON()`, the [`flattenMaps` option](https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()) defaults to `true`, because `JSON.stringify()` doesn't convert maps to objects by default.
 * When you call `toObject()`, the `flattenMaps` option is `false` by default.
 *
 * See [schema options](https://mongoosejs.com/docs/guide.html#toJSON) for more information on setting `toJSON` option defaults.
 *
 * @param {Object} options
 * @param {Boolean} [options.flattenMaps=true] if true, convert Maps to [POJOs](https://masteringjs.io/tutorials/fundamentals/pojo). Useful if you want to `JSON.stringify()` the result.
 * @param {Boolean} [options.flattenObjectIds=false] if true, convert any ObjectIds in the result to 24 character hex strings.
 * @return {Object}
 * @see Document#toObject https://mongoosejs.com/docs/api/document.html#Document.prototype.toObject()
>>>>>>> origin/wsj
 * @see JSON.stringify() in JavaScript https://thecodebarbarian.com/the-80-20-guide-to-json-stringify-in-javascript.html
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.toJSON = function(options) {
  return this.$toObject(options, true);
};

<<<<<<< HEAD
/**
 * If this document is a subdocument or populated document, returns the document's
 * parent. Returns `undefined` otherwise.
 *
=======
/*!
 * ignore
 */

Document.prototype.ownerDocument = function() {
  return this;
};


/**
 * If this document is a subdocument or populated document, returns the document's
 * parent. Returns the original document if there is no parent.
 *
 * @return {Document}
>>>>>>> origin/wsj
 * @api public
 * @method parent
 * @memberOf Document
 * @instance
 */

Document.prototype.parent = function() {
<<<<<<< HEAD
  return this.$__.parent;
};

/**
 * Alias for `parent()`. If this document is a subdocument or populated
 * document, returns the document's parent. Returns `undefined` otherwise.
 *
=======
  if (this.$isSubdocument || this.$__.wasPopulated) {
    return this.$__.parent;
  }
  return this;
};

/**
 * Alias for [`parent()`](https://mongoosejs.com/docs/api/document.html#Document.prototype.parent()). If this document is a subdocument or populated
 * document, returns the document's parent. Returns `undefined` otherwise.
 *
 * @return {Document}
>>>>>>> origin/wsj
 * @api public
 * @method $parent
 * @memberOf Document
 * @instance
 */

Document.prototype.$parent = Document.prototype.parent;

/**
 * Helper for console.log
 *
<<<<<<< HEAD
=======
 * @return {String}
>>>>>>> origin/wsj
 * @api public
 * @method inspect
 * @memberOf Document
 * @instance
 */

Document.prototype.inspect = function(options) {
  const isPOJO = utils.isPOJO(options);
  let opts;
  if (isPOJO) {
    opts = options;
    opts.minimize = false;
  }
<<<<<<< HEAD
  const ret = this.toObject(opts);
=======

  const ret = arguments.length > 0 ? this.toObject(opts) : this.toObject();
>>>>>>> origin/wsj

  if (ret == null) {
    // If `toObject()` returns null, `this` is still an object, so if `inspect()`
    // prints out null this can cause some serious confusion. See gh-7942.
    return 'MongooseDocument { ' + ret + ' }';
  }

  return ret;
};

if (inspect.custom) {
<<<<<<< HEAD
  /*!
  * Avoid Node deprecation warning DEP0079
  */

=======
  // Avoid Node deprecation warning DEP0079
>>>>>>> origin/wsj
  Document.prototype[inspect.custom] = Document.prototype.inspect;
}

/**
 * Helper for console.log
 *
<<<<<<< HEAD
=======
 * @return {String}
>>>>>>> origin/wsj
 * @api public
 * @method toString
 * @memberOf Document
 * @instance
 */

Document.prototype.toString = function() {
  const ret = this.inspect();
  if (typeof ret === 'string') {
    return ret;
  }
  return inspect(ret);
};

/**
 * Returns true if this document is equal to another document.
 *
 * Documents are considered equal when they have matching `_id`s, unless neither
 * document has an `_id`, in which case this function falls back to using
 * `deepEqual()`.
 *
<<<<<<< HEAD
 * @param {Document} doc a document to compare
=======
 * @param {Document} [doc] a document to compare. If falsy, will always return "false".
>>>>>>> origin/wsj
 * @return {Boolean}
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.equals = function(doc) {
  if (!doc) {
    return false;
  }

  const tid = this.$__getValue('_id');
  const docid = doc.$__ != null ? doc.$__getValue('_id') : doc;
  if (!tid && !docid) {
    return deepEqual(this, doc);
  }
  return tid && tid.equals
    ? tid.equals(docid)
    : tid === docid;
};

/**
<<<<<<< HEAD
 * Populates document references, executing the `callback` when complete.
 * If you want to use promises instead, use this function with
 * [`execPopulate()`](#document_Document-execPopulate)
 *
 * ####Example:
 *
 *     doc
 *     .populate('company')
 *     .populate({
 *       path: 'notes',
 *       match: /airline/,
 *       select: 'text',
 *       model: 'modelName'
 *       options: opts
 *     }, function (err, user) {
 *       assert(doc._id === user._id) // the document itself is passed
 *     })
 *
 *     // summary
 *     doc.populate(path)                   // not executed
 *     doc.populate(options);               // not executed
 *     doc.populate(path, callback)         // executed
 *     doc.populate(options, callback);     // executed
 *     doc.populate(callback);              // executed
 *     doc.populate(options).execPopulate() // executed, returns promise
 *
 *
 * ####NOTE:
 *
 * Population does not occur unless a `callback` is passed *or* you explicitly
 * call `execPopulate()`.
 * Passing the same path a second time will overwrite the previous path options.
 * See [Model.populate()](#model_Model.populate) for explaination of options.
 *
 * @see Model.populate #model_Model.populate
 * @see Document.execPopulate #document_Document-execPopulate
 * @param {String|Object} [path] The path to populate or an options object
 * @param {Function} [callback] When passed, population is invoked
 * @api public
 * @return {Document} this
 * @memberOf Document
 * @instance
 */

Document.prototype.populate = function populate() {
  if (arguments.length === 0) {
    return this;
  }

  const pop = this.$__.populate || (this.$__.populate = {});
  const args = utils.args(arguments);
  let fn;

  if (typeof args[args.length - 1] === 'function') {
    fn = args.pop();
  }

  // allow `doc.populate(callback)`
  if (args.length) {
=======
 * Populates paths on an existing document.
 *
 * #### Example:
 *
 *     // Given a document, `populate()` lets you pull in referenced docs
 *     await doc.populate([
 *       'stories',
 *       { path: 'fans', sort: { name: -1 } }
 *     ]);
 *     doc.populated('stories'); // Array of ObjectIds
 *     doc.stories[0].title; // 'Casino Royale'
 *     doc.populated('fans'); // Array of ObjectIds
 *
 *     // If the referenced doc has been deleted, `populate()` will
 *     // remove that entry from the array.
 *     await Story.delete({ title: 'Casino Royale' });
 *     await doc.populate('stories'); // Empty array
 *
 *     // You can also pass additional query options to `populate()`,
 *     // like projections:
 *     await doc.populate('fans', '-email');
 *     doc.fans[0].email // undefined because of 2nd param `select`
 *
 * @param {String|Object|Array} path either the path to populate or an object specifying all parameters, or either an array of those
 * @param {Object|String} [select] Field selection for the population query
 * @param {Model} [model] The model you wish to use for population. If not specified, populate will look up the model by the name in the Schema's `ref` field.
 * @param {Object} [match] Conditions for the population query
 * @param {Object} [options] Options for the population query (sort, etc)
 * @param {String} [options.path=null] The path to populate.
 * @param {string|PopulateOptions} [options.populate=null] Recursively populate paths in the populated documents. See [deep populate docs](https://mongoosejs.com/docs/populate.html#deep-populate).
 * @param {boolean} [options.retainNullValues=false] by default, Mongoose removes null and undefined values from populated arrays. Use this option to make `populate()` retain `null` and `undefined` array entries.
 * @param {boolean} [options.getters=false] if true, Mongoose will call any getters defined on the `localField`. By default, Mongoose gets the raw value of `localField`. For example, you would need to set this option to `true` if you wanted to [add a `lowercase` getter to your `localField`](https://mongoosejs.com/docs/schematypes.html#schematype-options).
 * @param {boolean} [options.clone=false] When you do `BlogPost.find().populate('author')`, blog posts with the same author will share 1 copy of an `author` doc. Enable this option to make Mongoose clone populated docs before assigning them.
 * @param {Object|Function} [options.match=null] Add an additional filter to the populate query. Can be a filter object containing [MongoDB query syntax](https://www.mongodb.com/docs/manual/tutorial/query-documents/), or a function that returns a filter object.
 * @param {Function} [options.transform=null] Function that Mongoose will call on every populated document that allows you to transform the populated document.
 * @param {Object} [options.options=null] Additional options like `limit` and `lean`.
 * @param {Function} [callback] Callback
 * @see population https://mongoosejs.com/docs/populate.html
 * @see Query#select https://mongoosejs.com/docs/api/query.html#Query.prototype.select()
 * @see Model.populate https://mongoosejs.com/docs/api/model.html#Model.populate()
 * @memberOf Document
 * @instance
 * @return {Promise|null} Returns a Promise if no `callback` is given.
 * @api public
 */

Document.prototype.populate = async function populate() {
  const pop = {};
  const args = [...arguments];
  if (typeof args[args.length - 1] === 'function') {
    throw new MongooseError('Document.prototype.populate() no longer accepts a callback');
  }

  if (args.length !== 0) {
>>>>>>> origin/wsj
    // use hash to remove duplicate paths
    const res = utils.populate.apply(null, args);
    for (const populateOptions of res) {
      pop[populateOptions.path] = populateOptions;
    }
  }

<<<<<<< HEAD
  if (fn) {
    const paths = utils.object.vals(pop);
    this.$__.populate = undefined;
    let topLevelModel = this.constructor;
    if (this.$__isNested) {
      topLevelModel = this.$__[scopeSymbol].constructor;
      const nestedPath = this.$__.nestedPath;
      paths.forEach(function(populateOptions) {
        populateOptions.path = nestedPath + '.' + populateOptions.path;
      });
    }

    // Use `$session()` by default if the document has an associated session
    // See gh-6754
    if (this.$session() != null) {
      const session = this.$session();
      paths.forEach(path => {
        if (path.options == null) {
          path.options = { session: session };
          return;
        }
        if (!('session' in path.options)) {
          path.options.session = session;
        }
      });
    }

    topLevelModel.populate(this, paths, fn);
  }

  return this;
=======
  const paths = utils.object.vals(pop);
  let topLevelModel = this.constructor;
  if (this.$__isNested) {
    topLevelModel = this.$__[scopeSymbol].constructor;
    const nestedPath = this.$__.nestedPath;
    paths.forEach(function(populateOptions) {
      populateOptions.path = nestedPath + '.' + populateOptions.path;
    });
  }

  // Use `$session()` by default if the document has an associated session
  // See gh-6754
  if (this.$session() != null) {
    const session = this.$session();
    paths.forEach(path => {
      if (path.options == null) {
        path.options = { session: session };
        return;
      }
      if (!('session' in path.options)) {
        path.options.session = session;
      }
    });
  }

  paths.forEach(p => {
    p._localModel = topLevelModel;
  });

  return topLevelModel.populate(this, paths);
>>>>>>> origin/wsj
};

/**
 * Gets all populated documents associated with this document.
 *
 * @api public
<<<<<<< HEAD
 * @return {Array<Document>} array of populated documents. Empty array if there are no populated documents associated with this document.
 * @memberOf Document
 * @instance
 */
=======
 * @return {Document[]} array of populated documents. Empty array if there are no populated documents associated with this document.
 * @memberOf Document
 * @method $getPopulatedDocs
 * @instance
 */

>>>>>>> origin/wsj
Document.prototype.$getPopulatedDocs = function $getPopulatedDocs() {
  let keys = [];
  if (this.$__.populated != null) {
    keys = keys.concat(Object.keys(this.$__.populated));
  }
<<<<<<< HEAD
  if (this.$$populatedVirtuals != null) {
    keys = keys.concat(Object.keys(this.$$populatedVirtuals));
  }
  let result = [];
  for (const key of keys) {
    const value = this.get(key);
=======
  let result = [];
  for (const key of keys) {
    const value = this.$get(key);
>>>>>>> origin/wsj
    if (Array.isArray(value)) {
      result = result.concat(value);
    } else if (value instanceof Document) {
      result.push(value);
    }
  }
  return result;
};

/**
<<<<<<< HEAD
 * Explicitly executes population and returns a promise. Useful for promises integration.
 *
 * ####Example:
 *
 *     const promise = doc.
 *       populate('company').
 *       populate({
 *         path: 'notes',
 *         match: /airline/,
 *         select: 'text',
 *         model: 'modelName'
 *         options: opts
 *       }).
 *       execPopulate();
 *
 *     // summary
 *     doc.execPopulate().then(resolve, reject);
 *
 *   // you can also use doc.execPopulate(options) as a shorthand for
 *   // doc.populate(options).execPopulate()
 *
 *
 * ####Example:
 *   const promise = doc.execPopulate({ path: 'company', select: 'employees' });
 *
 *   // summary
 *   promise.then(resolve,reject);
 *
 * @see Document.populate #document_Document-populate
 * @api public
 * @param {Function} [callback] optional callback. If specified, a promise will **not** be returned
 * @return {Promise} promise that resolves to the document when population is done
 * @memberOf Document
 * @instance
 */

Document.prototype.execPopulate = function(callback) {
  const isUsingShorthand = callback != null && typeof callback !== 'function';
  if (isUsingShorthand) {
    return this.populate.apply(this, arguments).execPopulate();
  }

  return promiseOrCallback(callback, cb => {
    this.populate(cb);
  }, this.constructor.events);
};

/**
 * Gets _id(s) used during population of the given `path`.
 *
 * ####Example:
 *
 *     Model.findOne().populate('author').exec(function (err, doc) {
 *       console.log(doc.author.name)         // Dr.Seuss
 *       console.log(doc.populated('author')) // '5144cf8050f071d979c118a7'
 *     })
=======
 * Gets _id(s) used during population of the given `path`.
 *
 * #### Example:
 *
 *     const doc = await Model.findOne().populate('author');
 *
 *     console.log(doc.author.name); // Dr.Seuss
 *     console.log(doc.populated('author')); // '5144cf8050f071d979c118a7'
>>>>>>> origin/wsj
 *
 * If the path was not populated, returns `undefined`.
 *
 * @param {String} path
<<<<<<< HEAD
=======
 * @param {Any} [val]
 * @param {Object} [options]
>>>>>>> origin/wsj
 * @return {Array|ObjectId|Number|Buffer|String|undefined}
 * @memberOf Document
 * @instance
 * @api public
 */

Document.prototype.populated = function(path, val, options) {
  // val and options are internal
  if (val == null || val === true) {
    if (!this.$__.populated) {
      return undefined;
    }
<<<<<<< HEAD
=======
    if (typeof path !== 'string') {
      return undefined;
    }
>>>>>>> origin/wsj

    // Map paths can be populated with either `path.$*` or just `path`
    const _path = path.endsWith('.$*') ? path.replace(/\.\$\*$/, '') : path;

    const v = this.$__.populated[_path];
    if (v) {
      return val === true ? v : v.value;
    }
    return undefined;
  }

  this.$__.populated || (this.$__.populated = {});
  this.$__.populated[path] = { value: val, options: options };

  // If this was a nested populate, make sure each populated doc knows
  // about its populated children (gh-7685)
  const pieces = path.split('.');
  for (let i = 0; i < pieces.length - 1; ++i) {
    const subpath = pieces.slice(0, i + 1).join('.');
<<<<<<< HEAD
    const subdoc = this.get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.populated(rest, val, options);
=======
    const subdoc = this.$get(subpath);
    if (subdoc != null && subdoc.$__ != null && this.$populated(subpath)) {
      const rest = pieces.slice(i + 1).join('.');
      subdoc.$populated(rest, val, options);
>>>>>>> origin/wsj
      // No need to continue because the above recursion should take care of
      // marking the rest of the docs as populated
      break;
    }
  }

  return val;
};

/**
<<<<<<< HEAD
 * Takes a populated field and returns it to its unpopulated state.
 *
 * ####Example:
=======
 * Alias of [`.populated`](https://mongoosejs.com/docs/api/document.html#Document.prototype.populated()).
 *
 * @method $populated
 * @memberOf Document
 * @api public
 */

Document.prototype.$populated = Document.prototype.populated;

/**
 * Throws an error if a given path is not populated
 *
 * #### Example:
 *
 *     const doc = await Model.findOne().populate('author');
 *
 *     doc.$assertPopulated('author'); // does not throw
 *     doc.$assertPopulated('other path'); // throws an error
 *
 *     // Manually populate and assert in one call. The following does
 *     // `doc.$set({ likes })` before asserting.
 *     doc.$assertPopulated('likes', { likes });
 *
 *
 * @param {String|String[]} path path or array of paths to check. `$assertPopulated` throws if any of the given paths is not populated.
 * @param {Object} [values] optional values to `$set()`. Convenient if you want to manually populate a path and assert that the path was populated in 1 call.
 * @return {Document} this
 * @memberOf Document
 * @method $assertPopulated
 * @instance
 * @api public
 */

Document.prototype.$assertPopulated = function $assertPopulated(path, values) {
  if (Array.isArray(path)) {
    path.forEach(p => this.$assertPopulated(p, values));
    return this;
  }

  if (arguments.length > 1) {
    this.$set(values);
  }

  if (!this.$populated(path)) {
    throw new MongooseError(`Expected path "${path}" to be populated`);
  }

  return this;
};

/**
 * Takes a populated field and returns it to its unpopulated state.
 *
 * #### Example:
>>>>>>> origin/wsj
 *
 *     Model.findOne().populate('author').exec(function (err, doc) {
 *       console.log(doc.author.name); // Dr.Seuss
 *       console.log(doc.depopulate('author'));
 *       console.log(doc.author); // '5144cf8050f071d979c118a7'
 *     })
 *
 * If the path was not provided, then all populated fields are returned to their unpopulated state.
 *
<<<<<<< HEAD
 * @param {String} path
 * @return {Document} this
 * @see Document.populate #document_Document-populate
=======
 * @param {String|String[]} [path] Specific Path to depopulate. If unset, will depopulate all paths on the Document. Or multiple space-delimited paths.
 * @return {Document} this
 * @see Document.populate https://mongoosejs.com/docs/api/document.html#Document.prototype.populate()
>>>>>>> origin/wsj
 * @api public
 * @memberOf Document
 * @instance
 */

Document.prototype.depopulate = function(path) {
  if (typeof path === 'string') {
<<<<<<< HEAD
    path = path.split(' ');
=======
    path = path.indexOf(' ') === -1 ? [path] : path.split(' ');
>>>>>>> origin/wsj
  }

  let populatedIds;
  const virtualKeys = this.$$populatedVirtuals ? Object.keys(this.$$populatedVirtuals) : [];
<<<<<<< HEAD
  const populated = get(this, '$__.populated', {});
=======
  const populated = this.$__ && this.$__.populated || {};
>>>>>>> origin/wsj

  if (arguments.length === 0) {
    // Depopulate all
    for (const virtualKey of virtualKeys) {
      delete this.$$populatedVirtuals[virtualKey];
      delete this._doc[virtualKey];
      delete populated[virtualKey];
    }

    const keys = Object.keys(populated);

    for (const key of keys) {
<<<<<<< HEAD
      populatedIds = this.populated(key);
=======
      populatedIds = this.$populated(key);
>>>>>>> origin/wsj
      if (!populatedIds) {
        continue;
      }
      delete populated[key];
<<<<<<< HEAD
      this.$set(key, populatedIds);
=======
      if (Array.isArray(populatedIds)) {
        const arr = utils.getValue(key, this._doc);
        if (arr.isMongooseArray) {
          const rawArray = arr.__array;
          for (let i = 0; i < rawArray.length; ++i) {
            const subdoc = rawArray[i];
            if (subdoc == null) {
              continue;
            }
            rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
          }
        } else {
          utils.setValue(key, populatedIds, this._doc);
        }
      } else {
        utils.setValue(key, populatedIds, this._doc);
      }
>>>>>>> origin/wsj
    }
    return this;
  }

  for (const singlePath of path) {
<<<<<<< HEAD
    populatedIds = this.populated(singlePath);
=======
    populatedIds = this.$populated(singlePath);
>>>>>>> origin/wsj
    delete populated[singlePath];

    if (virtualKeys.indexOf(singlePath) !== -1) {
      delete this.$$populatedVirtuals[singlePath];
      delete this._doc[singlePath];
    } else if (populatedIds) {
<<<<<<< HEAD
      this.$set(singlePath, populatedIds);
=======
      if (Array.isArray(populatedIds)) {
        const arr = utils.getValue(singlePath, this._doc);
        if (arr.isMongooseArray) {
          const rawArray = arr.__array;
          for (let i = 0; i < rawArray.length; ++i) {
            const subdoc = rawArray[i];
            if (subdoc == null) {
              continue;
            }
            rawArray[i] = subdoc instanceof Document ? subdoc._doc._id : subdoc._id;
          }
        } else {
          utils.setValue(singlePath, populatedIds, this._doc);
        }
      } else {
        utils.setValue(singlePath, populatedIds, this._doc);
      }
>>>>>>> origin/wsj
    }
  }
  return this;
};


/**
 * Returns the full path to this document.
 *
 * @param {String} [path]
 * @return {String}
 * @api private
 * @method $__fullPath
 * @memberOf Document
 * @instance
 */

Document.prototype.$__fullPath = function(path) {
  // overridden in SubDocuments
  return path || '';
};

/**
 * Returns the changes that happened to the document
 * in the format that will be sent to MongoDB.
 *
 * #### Example:
 *
 *     const userSchema = new Schema({
 *       name: String,
 *       age: Number,
 *       country: String
 *     });
 *     const User = mongoose.model('User', userSchema);
 *     const user = await User.create({
 *       name: 'Hafez',
 *       age: 25,
 *       country: 'Egypt'
 *     });
 *
 *     // returns an empty object, no changes happened yet
 *     user.getChanges(); // { }
 *
 *     user.country = undefined;
 *     user.age = 26;
 *
 *     user.getChanges(); // { $set: { age: 26 }, { $unset: { country: 1 } } }
 *
 *     await user.save();
 *
 *     user.getChanges(); // { }
 *
 * Modifying the object that `getChanges()` returns does not affect the document's
 * change tracking state. Even if you `delete user.getChanges().$set`, Mongoose
 * will still send a `$set` to the server.
 *
 * @return {Object}
 * @api public
 * @method getChanges
 * @memberOf Document
 * @instance
 */

Document.prototype.getChanges = function() {
  const delta = this.$__delta();
  const changes = delta ? delta[1] : {};
  return changes;
};

<<<<<<< HEAD
=======
/**
 * Produces a special query document of the modified properties used in updates.
 *
 * @api private
 * @method $__delta
 * @memberOf Document
 * @instance
 */

Document.prototype.$__delta = function $__delta() {
  const dirty = this.$__dirty();
  const optimisticConcurrency = this.$__schema.options.optimisticConcurrency;
  if (optimisticConcurrency) {
    if (Array.isArray(optimisticConcurrency)) {
      const optCon = new Set(optimisticConcurrency);
      const modPaths = this.modifiedPaths();
      if (modPaths.find(path => optCon.has(path))) {
        this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
      }
    } else {
      this.$__.version = dirty.length ? VERSION_ALL : VERSION_WHERE;
    }
  }

  if (!dirty.length && VERSION_ALL !== this.$__.version) {
    return;
  }
  const where = {};
  const delta = {};
  const len = dirty.length;
  const divergent = [];
  let d = 0;

  where._id = this._doc._id;
  // If `_id` is an object, need to depopulate, but also need to be careful
  // because `_id` can technically be null (see gh-6406)
  if ((where && where._id && where._id.$__ || null) != null) {
    where._id = where._id.toObject({ transform: false, depopulate: true });
  }
  for (; d < len; ++d) {
    const data = dirty[d];
    let value = data.value;
    const match = checkDivergentArray(this, data.path, value);
    if (match) {
      divergent.push(match);
      continue;
    }

    const pop = this.$populated(data.path, true);
    if (!pop && this.$__.selected) {
      // If any array was selected using an $elemMatch projection, we alter the path and where clause
      // NOTE: MongoDB only supports projected $elemMatch on top level array.
      const pathSplit = data.path.split('.');
      const top = pathSplit[0];
      if (this.$__.selected[top] && this.$__.selected[top].$elemMatch) {
        // If the selected array entry was modified
        if (pathSplit.length > 1 && pathSplit[1] == 0 && typeof where[top] === 'undefined') {
          where[top] = this.$__.selected[top];
          pathSplit[1] = '$';
          data.path = pathSplit.join('.');
        }
        // if the selected array was modified in any other way throw an error
        else {
          divergent.push(data.path);
          continue;
        }
      }
    }

    // If this path is set to default, and either this path or one of
    // its parents is excluded, don't treat this path as dirty.
    if (this.$isDefault(data.path) && this.$__.selected) {
      if (data.path.indexOf('.') === -1 && isPathExcluded(this.$__.selected, data.path)) {
        continue;
      }

      const pathsToCheck = parentPaths(data.path);
      if (pathsToCheck.find(path => isPathExcluded(this.$__.isSelected, path))) {
        continue;
      }
    }

    if (divergent.length) continue;
    if (value === undefined) {
      operand(this, where, delta, data, 1, '$unset');
    } else if (value === null) {
      operand(this, where, delta, data, null);
    } else if (utils.isMongooseArray(value) && value.$path() && value[arrayAtomicsSymbol]) {
      // arrays and other custom types (support plugins etc)
      handleAtomics(this, where, delta, data, value);
    } else if (value[MongooseBuffer.pathSymbol] && Buffer.isBuffer(value)) {
      // MongooseBuffer
      value = value.toObject();
      operand(this, where, delta, data, value);
    } else {
      if (this.$__.primitiveAtomics && this.$__.primitiveAtomics[data.path] != null) {
        const val = this.$__.primitiveAtomics[data.path];
        const op = firstKey(val);
        operand(this, where, delta, data, val[op], op);
      } else {
        value = clone(value, {
          depopulate: true,
          transform: false,
          virtuals: false,
          getters: false,
          omitUndefined: true,
          _isNested: true
        });
        operand(this, where, delta, data, value);
      }
    }
  }

  if (divergent.length) {
    return new DivergentArrayError(divergent);
  }

  if (this.$__.version) {
    this.$__version(where, delta);
  }

  if (Object.keys(delta).length === 0) {
    return [where, null];
  }

  return [where, delta];
};

/**
 * Determine if array was populated with some form of filter and is now
 * being updated in a manner which could overwrite data unintentionally.
 *
 * @see https://github.com/Automattic/mongoose/issues/1334
 * @param {Document} doc
 * @param {String} path
 * @param {Any} array
 * @return {String|undefined}
 * @api private
 */

function checkDivergentArray(doc, path, array) {
  // see if we populated this path
  const pop = doc.$populated(path, true);

  if (!pop && doc.$__.selected) {
    // If any array was selected using an $elemMatch projection, we deny the update.
    // NOTE: MongoDB only supports projected $elemMatch on top level array.
    const top = path.split('.')[0];
    if (doc.$__.selected[top + '.$']) {
      return top;
    }
  }

  if (!(pop && utils.isMongooseArray(array))) return;

  // If the array was populated using options that prevented all
  // documents from being returned (match, skip, limit) or they
  // deselected the _id field, $pop and $set of the array are
  // not safe operations. If _id was deselected, we do not know
  // how to remove elements. $pop will pop off the _id from the end
  // of the array in the db which is not guaranteed to be the
  // same as the last element we have here. $set of the entire array
  // would be similarly destructive as we never received all
  // elements of the array and potentially would overwrite data.
  const check = pop.options.match ||
      pop.options.options && utils.object.hasOwnProperty(pop.options.options, 'limit') || // 0 is not permitted
      pop.options.options && pop.options.options.skip || // 0 is permitted
      pop.options.select && // deselected _id?
      (pop.options.select._id === 0 ||
      /\s?-_id\s?/.test(pop.options.select));

  if (check) {
    const atomics = array[arrayAtomicsSymbol];
    if (Object.keys(atomics).length === 0 || atomics.$set || atomics.$pop) {
      return path;
    }
  }
}

/**
 * Apply the operation to the delta (update) clause as
 * well as track versioning for our where clause.
 *
 * @param {Document} self
 * @param {Object} where Unused
 * @param {Object} delta
 * @param {Object} data
 * @param {Mixed} val
 * @param {String} [op]
 * @api private
 */

function operand(self, where, delta, data, val, op) {
  // delta
  op || (op = '$set');
  if (!delta[op]) delta[op] = {};
  delta[op][data.path] = val;
  // disabled versioning?
  if (self.$__schema.options.versionKey === false) return;

  // path excluded from versioning?
  if (shouldSkipVersioning(self, data.path)) return;

  // already marked for versioning?
  if (VERSION_ALL === (VERSION_ALL & self.$__.version)) return;

  if (self.$__schema.options.optimisticConcurrency) {
    return;
  }

  switch (op) {
    case '$set':
    case '$unset':
    case '$pop':
    case '$pull':
    case '$pullAll':
    case '$push':
    case '$addToSet':
    case '$inc':
      break;
    default:
      // nothing to do
      return;
  }

  // ensure updates sent with positional notation are
  // editing the correct array element.
  // only increment the version if an array position changes.
  // modifying elements of an array is ok if position does not change.
  if (op === '$push' || op === '$addToSet' || op === '$pullAll' || op === '$pull') {
    if (/\.\d+\.|\.\d+$/.test(data.path)) {
      self.$__.version = VERSION_ALL;
    } else {
      self.$__.version = VERSION_INC;
    }
  } else if (/^\$p/.test(op)) {
    // potentially changing array positions
    self.$__.version = VERSION_ALL;
  } else if (Array.isArray(val)) {
    // $set an array
    self.$__.version = VERSION_ALL;
  } else if (/\.\d+\.|\.\d+$/.test(data.path)) {
    // now handling $set, $unset
    // subpath of array
    self.$__.version = VERSION_WHERE;
  }
}

/**
 * Compiles an update and where clause for a `val` with _atomics.
 *
 * @param {Document} self
 * @param {Object} where
 * @param {Object} delta
 * @param {Object} data
 * @param {Array} value
 * @api private
 */

function handleAtomics(self, where, delta, data, value) {
  if (delta.$set && delta.$set[data.path]) {
    // $set has precedence over other atomics
    return;
  }

  if (typeof value.$__getAtomics === 'function') {
    value.$__getAtomics().forEach(function(atomic) {
      const op = atomic[0];
      const val = atomic[1];
      operand(self, where, delta, data, val, op);
    });
    return;
  }

  // legacy support for plugins

  const atomics = value[arrayAtomicsSymbol];
  const ops = Object.keys(atomics);
  let i = ops.length;
  let val;
  let op;

  if (i === 0) {
    // $set

    if (utils.isMongooseObject(value)) {
      value = value.toObject({ depopulate: 1, _isNested: true });
    } else if (value.valueOf) {
      value = value.valueOf();
    }

    return operand(self, where, delta, data, value);
  }

  function iter(mem) {
    return utils.isMongooseObject(mem)
      ? mem.toObject({ depopulate: 1, _isNested: true })
      : mem;
  }

  while (i--) {
    op = ops[i];
    val = atomics[op];

    if (utils.isMongooseObject(val)) {
      val = val.toObject({ depopulate: true, transform: false, _isNested: true });
    } else if (Array.isArray(val)) {
      val = val.map(iter);
    } else if (val.valueOf) {
      val = val.valueOf();
    }

    if (op === '$addToSet') {
      val = { $each: val };
    }

    operand(self, where, delta, data, val, op);
  }
}

/**
 * Determines whether versioning should be skipped for the given path
 *
 * @param {Document} self
 * @param {String} path
 * @return {Boolean} true if versioning should be skipped for the given path
 * @api private
 */
function shouldSkipVersioning(self, path) {
  const skipVersioning = self.$__schema.options.skipVersioning;
  if (!skipVersioning) return false;

  // Remove any array indexes from the path
  path = path.replace(/\.\d+\./, '.');

  return skipVersioning[path];
}

/**
 * Returns a copy of this document with a deep clone of `_doc` and `$__`.
 *
 * @return {Document} a copy of this document
 * @api public
 * @method $clone
 * @memberOf Document
 * @instance
 */

Document.prototype.$clone = function() {
  const Model = this.constructor;
  const clonedDoc = new Model();
  clonedDoc.$isNew = this.$isNew;
  if (this._doc) {
    clonedDoc._doc = clone(this._doc, { retainDocuments: true });
  }
  if (this.$__) {
    const Cache = this.$__.constructor;
    const clonedCache = new Cache();
    for (const key of Object.getOwnPropertyNames(this.$__)) {
      if (key === 'activePaths') {
        continue;
      }
      clonedCache[key] = clone(this.$__[key]);
    }
    Object.assign(clonedCache.activePaths, clone({ ...this.$__.activePaths }));
    clonedDoc.$__ = clonedCache;
  }
  return clonedDoc;
};

/**
 * Creates a snapshot of this document's internal change tracking state. You can later
 * reset this document's change tracking state using `$restoreModifiedPathsSnapshot()`.
 *
 * #### Example:
 *
 *     const doc = await TestModel.findOne();
 *     const snapshot = doc.$createModifiedPathsSnapshot();
 *
 * @return {ModifiedPathsSnapshot} a copy of this document's internal change tracking state
 * @api public
 * @method $createModifiedPathsSnapshot
 * @memberOf Document
 * @instance
 */

Document.prototype.$createModifiedPathsSnapshot = function $createModifiedPathsSnapshot() {
  const subdocSnapshot = new WeakMap();
  if (!this.$isSubdocument) {
    const subdocs = this.$getAllSubdocs();
    for (const child of subdocs) {
      subdocSnapshot.set(child, child.$__.activePaths.clone());
    }
  }

  return new ModifiedPathsSnapshot(
    subdocSnapshot,
    this.$__.activePaths.clone(),
    this.$__.version
  );
};

/**
 * Restore this document's change tracking state to the given snapshot.
 * Note that `$restoreModifiedPathsSnapshot()` does **not** modify the document's
 * properties, just resets the change tracking state.
 *
 * This method is especially useful when writing [custom transaction wrappers](https://github.com/Automattic/mongoose/issues/14268#issuecomment-2100505554) that need to restore change tracking when aborting a transaction.
 *
 * #### Example:
 *
 *     const doc = await TestModel.findOne();
 *     const snapshot = doc.$createModifiedPathsSnapshot();
 *
 *     doc.name = 'test';
 *     doc.$restoreModifiedPathsSnapshot(snapshot);
 *     doc.$isModified('name'); // false because `name` was not modified when snapshot was taken
 *     doc.name; // 'test', `$restoreModifiedPathsSnapshot()` does **not** modify the document's data, only change tracking
 *
 * @param {ModifiedPathsSnapshot} snapshot of the document's internal change tracking state snapshot to restore
 * @api public
 * @method $restoreModifiedPathsSnapshot
 * @return {Document} this
 * @memberOf Document
 * @instance
 */

Document.prototype.$restoreModifiedPathsSnapshot = function $restoreModifiedPathsSnapshot(snapshot) {
  this.$__.activePaths = snapshot.activePaths.clone();
  this.$__.version = snapshot.version;
  if (!this.$isSubdocument) {
    const subdocs = this.$getAllSubdocs();
    for (const child of subdocs) {
      if (snapshot.subdocSnapshot.has(child)) {
        child.$__.activePaths = snapshot.subdocSnapshot.get(child);
      }
    }
  }

  return this;
};

/**
 * Clear the document's modified paths.
 *
 * #### Example:
 *
 *     const doc = await TestModel.findOne();
 *
 *     doc.name = 'test';
 *     doc.$isModified('name'); // true
 *
 *     doc.$clearModifiedPaths();
 *     doc.name; // 'test', `$clearModifiedPaths()` does **not** modify the document's data, only change tracking
 *
 * @api public
 * @return {Document} this
 * @method $clearModifiedPaths
 * @memberOf Document
 * @instance
 */

Document.prototype.$clearModifiedPaths = function $clearModifiedPaths() {
  this.$__.activePaths.clear('modify');
  this.$__.activePaths.clear('init');
  this.$__.version = 0;
  if (!this.$isSubdocument) {
    const subdocs = this.$getAllSubdocs();
    for (const child of subdocs) {
      child.$clearModifiedPaths();
    }
  }

  return this;
};

/*!
 * Check if the given document only has primitive values
 */

Document.prototype.$__hasOnlyPrimitiveValues = function $__hasOnlyPrimitiveValues() {
  return !this.$__.populated && !this.$__.wasPopulated && (this._doc == null || Object.values(this._doc).every(v => {
    return v == null
      || typeof v !== 'object'
      || (utils.isNativeObject(v) && !Array.isArray(v))
      || isBsonType(v, 'ObjectId')
      || isBsonType(v, 'Decimal128');
  }));
};

>>>>>>> origin/wsj
/*!
 * Module exports.
 */

<<<<<<< HEAD
=======
Document.VERSION_WHERE = VERSION_WHERE;
Document.VERSION_INC = VERSION_INC;
Document.VERSION_ALL = VERSION_ALL;
>>>>>>> origin/wsj
Document.ValidationError = ValidationError;
module.exports = exports = Document;
